{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"syfala v0.8.0 Automatic compilation of Faust and C++ audio DSP programs for AMD/Xilinx FPGA platforms. Supported platforms Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board and more to come... Dependencies Please follow the instructions in the file dependencies.md in order to install the AMD-Xilinx toolchain and various other dependencies. Installing the command make install will install a symlink in /usr/bin . After this you'll be able to just run on your terminal: syfala myfaustprogram.dsp You'll also have to edit your shell resource file (~/. bashrc / ~/. zshrc ) and set the following environment variable: export XILINX_ROOT_DIR=/my/path/to/Xilinx/root/directory XILINX_ROOT_DIR is the root directory where all of the AMD-Xilinx tools (Vivado, Vitis, Vitis_HLS) are installed. Tutorials Getting started with syfala and Faust tutorials/getting-started-faust.md In this tutorial, we will cover the essential topics to get you started with the Faust programming language , syfala , and audio programming on FPGAs . Embedded Linux Please report to the tutorials/embedded-linux-getting-started.md document in order to get you started with the Embedded Linux for Syfala Using syfala with C++ (advanced) tutorials/cpp-tutorial-advanced.md This tutorial will show you how to program a syfala DSP kernel using C++. It is intended for advanced users. Quick getting-started Software Faust targets Building a simple example for the default board (Digilent Zybo Z7-10) : syfala examples/faust/virtualAnalog.dsp This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on the board. Y ou can specify the targeted board using the -b (--board) option: syfala examples/faust/virtualAnalog.dsp --board Z20 syfala examples/faust/virtualAnalog.dsp --board GENESYS Once the build is finished (depending on your computer, it usually takes between 15 and 30 minutes to complete), you can connect the board to your computer with the proper USB/Serial port cable and run the flash command: syfala flash The board's RGB LED should then flash green after a few seconds, indicating that your program is running. You can now start the Faust GUI application , which will display a set of sliders/knobs/buttons and update the DSP parameters in real-time through USB-UART : syfala start-gui C++ targets For C++ targets, the process is exactly the same (excepted for the GUI part, which is not available): syfala examples/cpp/templates/bypass.cpp --board Z20 syfala flash Exporting and re-importing your builds When you're done playing with your program, you can save and export it as a .zip file with the following command: syfala export my-faust-virtual-analog-build # output in 'export/my-faust-virtual-analog-build.zip' The resulting .zip file is now available in the repository's export directory, you can re-import it by typing: syfala import export/my-faust-virtual-analog-build.zip Building another DSP target Before building another DSP program, please make sure you have saved and exported your previous build beforehand, otherwise it will be overwritten whenever you start a new build. syfala examples/my-new-dsp-build.dsp Hardware (Digilent Zybo-Z7-10/20 boards) Jumper JP5 should be on JTAG Power select jumper should be on USB Switches SW0, SW1, SW2, SW3 should be down The audio input is LINE IN (blue), not MIC IN The audio output is the black HPH OUT jack Going further Please report to the reference for more information on available commands , options and documentation. The syfala team Here is a list of person that have contributed to the Syfala project : Tanguy Risset Yann Orlarey Romain Michon Stephane Letz Florent de Dinechin Anastasia Volkova Alain Darte Yohan Uguen Gero M\u00fcller Adeyemi Gbadamosi Ousmane Touat Luc Forget Antonin Dudermel Maxime Popoff Thomas Delmas Oussama Bouksim Pierre Cochard Joseph Bizien Agathe Herrou Jurek Weber Alo\u00efs Rautureau Jessica Zaki-Sewa","title":"Home"},{"location":"#syfala-v080","text":"Automatic compilation of Faust and C++ audio DSP programs for AMD/Xilinx FPGA platforms.","title":"syfala v0.8.0"},{"location":"#supported-platforms","text":"Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board and more to come...","title":"Supported platforms"},{"location":"#dependencies","text":"Please follow the instructions in the file dependencies.md in order to install the AMD-Xilinx toolchain and various other dependencies.","title":"Dependencies"},{"location":"#installing","text":"the command make install will install a symlink in /usr/bin . After this you'll be able to just run on your terminal: syfala myfaustprogram.dsp You'll also have to edit your shell resource file (~/. bashrc / ~/. zshrc ) and set the following environment variable: export XILINX_ROOT_DIR=/my/path/to/Xilinx/root/directory XILINX_ROOT_DIR is the root directory where all of the AMD-Xilinx tools (Vivado, Vitis, Vitis_HLS) are installed.","title":"Installing"},{"location":"#tutorials","text":"","title":"Tutorials"},{"location":"#getting-started-with-syfala-and-faust","text":"tutorials/getting-started-faust.md In this tutorial, we will cover the essential topics to get you started with the Faust programming language , syfala , and audio programming on FPGAs .","title":"Getting started with syfala and Faust"},{"location":"#embedded-linux","text":"Please report to the tutorials/embedded-linux-getting-started.md document in order to get you started with the Embedded Linux for Syfala","title":"Embedded Linux"},{"location":"#using-syfala-with-c-advanced","text":"tutorials/cpp-tutorial-advanced.md This tutorial will show you how to program a syfala DSP kernel using C++. It is intended for advanced users.","title":"Using syfala with C++ (advanced)"},{"location":"#quick-getting-started","text":"","title":"Quick getting-started"},{"location":"#software","text":"","title":"Software"},{"location":"#faust-targets","text":"Building a simple example for the default board (Digilent Zybo Z7-10) : syfala examples/faust/virtualAnalog.dsp This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on the board. Y ou can specify the targeted board using the -b (--board) option: syfala examples/faust/virtualAnalog.dsp --board Z20 syfala examples/faust/virtualAnalog.dsp --board GENESYS Once the build is finished (depending on your computer, it usually takes between 15 and 30 minutes to complete), you can connect the board to your computer with the proper USB/Serial port cable and run the flash command: syfala flash The board's RGB LED should then flash green after a few seconds, indicating that your program is running. You can now start the Faust GUI application , which will display a set of sliders/knobs/buttons and update the DSP parameters in real-time through USB-UART : syfala start-gui","title":"Faust targets"},{"location":"#c-targets","text":"For C++ targets, the process is exactly the same (excepted for the GUI part, which is not available): syfala examples/cpp/templates/bypass.cpp --board Z20 syfala flash","title":"C++ targets"},{"location":"#exporting-and-re-importing-your-builds","text":"When you're done playing with your program, you can save and export it as a .zip file with the following command: syfala export my-faust-virtual-analog-build # output in 'export/my-faust-virtual-analog-build.zip' The resulting .zip file is now available in the repository's export directory, you can re-import it by typing: syfala import export/my-faust-virtual-analog-build.zip","title":"Exporting and re-importing your builds"},{"location":"#building-another-dsp-target","text":"Before building another DSP program, please make sure you have saved and exported your previous build beforehand, otherwise it will be overwritten whenever you start a new build. syfala examples/my-new-dsp-build.dsp","title":"Building another DSP target"},{"location":"#hardware-digilent-zybo-z7-1020-boards","text":"Jumper JP5 should be on JTAG Power select jumper should be on USB Switches SW0, SW1, SW2, SW3 should be down The audio input is LINE IN (blue), not MIC IN The audio output is the black HPH OUT jack","title":"Hardware (Digilent Zybo-Z7-10/20 boards)"},{"location":"#going-further","text":"Please report to the reference for more information on available commands , options and documentation.","title":"Going further"},{"location":"#the-syfala-team","text":"Here is a list of person that have contributed to the Syfala project : Tanguy Risset Yann Orlarey Romain Michon Stephane Letz Florent de Dinechin Anastasia Volkova Alain Darte Yohan Uguen Gero M\u00fcller Adeyemi Gbadamosi Ousmane Touat Luc Forget Antonin Dudermel Maxime Popoff Thomas Delmas Oussama Bouksim Pierre Cochard Joseph Bizien Agathe Herrou Jurek Weber Alo\u00efs Rautureau Jessica Zaki-Sewa","title":"The syfala team"},{"location":"manual/dependencies/","text":"Syfala toolchain dependencies The Syfala toolchain is a compilation toolchain of Faust programs onto AMD-Xilinx FPGA targets. This document explains how to install and run the version 0.10.0 of the toolchain on a Linux machine. In practice, installing the Syfala toolchain means: Installing the required linux-packages , depending on your Linux distribution. Installing the Faust compiler Creating a AMD-Xilinx account and downloading/installing the 2024.1 version (2022.2 and 2023.2 are also still supported) of the AMD-Xilinx toolchain (providing softwares such as Vivado, Vitis, Vitis HLS). Installing the additional Vivado Board Files for Digilent Boards. Installing udev rules in order to use the JTAG connection. Cloning the Syfala repository , and running a simple example to make sure everything is working properly. Linux platforms We recommend using Ubuntu (>= 18.04 LTS) for installing and using the toolchain, since it is officially supported by AMD-Xilinx. While it is still possible to use other distributions, such as Archlinux, you may encounter unresolved bugs, which won't necessarily appear in our Troubleshooting section below. Ubuntu dependencies sudo apt-get update sudo apt-get install git libncurses5 libtinfo-dev build-essential default-jre pkg-config g++-multilib gtk+2.0 locales Archlinux dependencies # faust (required) sudo pacman -S faust # for xilinx vivado/vitis etc. yay -S ncurses5-compat-libs libxcrypt-compat libpng12 lib32-libpng12 xorg-xlsclients gtk2 Faust It is recommended to clone Faust from the official github repository: https://github.com/grame-cncm/faust git clone https://github.com/grame-cncm/faust.git cd faust make -j8 sudo make install Vivado, Vitis & Vitis HLS (2024.1 version) Open an account on https://www.xilinx.com/registration The AMD-Xilinx download page contains links for downloading the Vivado Design Suite - HLx Editions - Full Product . It is available for both Linux and Windows. Download the Linux installer FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin and execute the following commands: chmod a+x FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin ./FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin We suggest to use the \" Download Image (Install Separately) \" option. It creates a directory with a xsetup file to execute that you can reuse in case of failure during the installation Execute ./xsetup Choose to install Vitis (it will still install Vivado , Vitis , and Vitis HLS ). It will need 110GB of disk space : if you uncheck Ultrascale , Ultrascale+ , Versal ACAP and Alveo acceleration platform , it will use less space and still work. Agree with everything and choose a directory to install (e.g. ~/Xilinx) Install and wait (it may take quite a while) Setup a shell environment variable allowing to use the tools when necessary (add this to your ~/.bashrc , ~/.zshrc or whatever you're currently using, replacing $XILINX_ROOT_DIR by the directory you chose to install all the tools) export XILINX_ROOT_DIR=$HOME/Xilinx Installing Cable Drivers on Linux cd $XILINX_ROOT_DIR/Vivado/2024.1/data/xicom/cable_drivers/lin64/install_script/install_drivers ./install_drivers # Allow JTAG-USB connection: sudo cp 52-xilinx-digilent-usb.rules /etc/udev/rules.d Installing Digilent Board Files Download the board files from github : Open the folder extracted from the archive and navigate to its new/board_files folder. You will be copying all of this folder's subfolders For the 2020.2 version , go to $XILINX_ROOT_DIR/Vivado/2020.2/data/boards/board_files For the 2022.2 version and above , go to $XILINX_ROOT_DIR/Vivado/202x.x/data/xhub/boards/XilinxBoardStore/boards/Xilinx Copy all of the folders found in vivado-boards new/board_files folder and paste them into this folder Cloning the Syfala repository To clone and install the latest stable version of the Syfala toolchain, you can use the following commands: git clone https://github.com/inria-emeraude/syfala cd syfala make install syfala --help In order to use the Syfala toolchain to compile your first example, please report to the main README file located in the repository's root directory. Troubleshooting On Archlinux , if you see an error like this one /lib/../lib64/crti.o: file not recognized: File format not recognized you'll have to rename the Vivado/202x.x/tps/lnx64/binutils-2.26 (Vitis will then search in the system libraries). Vitis/Java issues On recent systems (or with Archlinux ), you might have problems compiling the host-side ( ARM ) application. The problem is caused by system libraries requiring newer versions of GCC than the one provided by Vitis. Replacing GCC target in Vitis' path by system GCC works: cd $XILINX_ROOT_DIR/Vitis/202x.x/lib/lnx64.o/Default mv libstdc++.so.6 libstdc++.so.6.old rm -rf libstdc++.so (symlink) sudo ln -s /usr/lib/libstdc++.so.6 libstdc++.so.6 Installing the 2022 patch (AMD-Xilinx toolchain v2020.2 only) Vivado and Vitis tools that use HLS in the background are also affected by this issue. HLS tools set the ip_version in the format YYMMDDHHMM and this value is accessed as a signed integer (32-bit) that causes an overflow and generates the errors below (or something similar). Follow this link: https://support.xilinx.com/s/article/76960?language=en_US Download the file at the bottom of th page and unzip it in $XILINX_ROOT_DIR Run the following commands: cd $XILINX_ROOT_DIR export LD_LIBRARY_PATH=$PWD/Vivado/2020.2/tps/lnx64/python-3.8.3/lib/ Vivado/2022.2/tps/lnx64/python-3.8.3/bin/python3 y2k22_patch/patch.py","title":"Dependencies"},{"location":"manual/dependencies/#syfala-toolchain-dependencies","text":"The Syfala toolchain is a compilation toolchain of Faust programs onto AMD-Xilinx FPGA targets. This document explains how to install and run the version 0.10.0 of the toolchain on a Linux machine. In practice, installing the Syfala toolchain means: Installing the required linux-packages , depending on your Linux distribution. Installing the Faust compiler Creating a AMD-Xilinx account and downloading/installing the 2024.1 version (2022.2 and 2023.2 are also still supported) of the AMD-Xilinx toolchain (providing softwares such as Vivado, Vitis, Vitis HLS). Installing the additional Vivado Board Files for Digilent Boards. Installing udev rules in order to use the JTAG connection. Cloning the Syfala repository , and running a simple example to make sure everything is working properly.","title":"Syfala toolchain dependencies"},{"location":"manual/dependencies/#linux-platforms","text":"We recommend using Ubuntu (>= 18.04 LTS) for installing and using the toolchain, since it is officially supported by AMD-Xilinx. While it is still possible to use other distributions, such as Archlinux, you may encounter unresolved bugs, which won't necessarily appear in our Troubleshooting section below.","title":"Linux platforms"},{"location":"manual/dependencies/#ubuntu-dependencies","text":"sudo apt-get update sudo apt-get install git libncurses5 libtinfo-dev build-essential default-jre pkg-config g++-multilib gtk+2.0 locales","title":"Ubuntu dependencies"},{"location":"manual/dependencies/#archlinux-dependencies","text":"# faust (required) sudo pacman -S faust # for xilinx vivado/vitis etc. yay -S ncurses5-compat-libs libxcrypt-compat libpng12 lib32-libpng12 xorg-xlsclients gtk2","title":"Archlinux dependencies"},{"location":"manual/dependencies/#faust","text":"It is recommended to clone Faust from the official github repository: https://github.com/grame-cncm/faust git clone https://github.com/grame-cncm/faust.git cd faust make -j8 sudo make install","title":"Faust"},{"location":"manual/dependencies/#vivado-vitis-vitis-hls-20241-version","text":"Open an account on https://www.xilinx.com/registration The AMD-Xilinx download page contains links for downloading the Vivado Design Suite - HLx Editions - Full Product . It is available for both Linux and Windows. Download the Linux installer FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin and execute the following commands: chmod a+x FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin ./FPGAs_AdaptiveSoCs_Unified_2024.1_0522_2023_Lin64.bin We suggest to use the \" Download Image (Install Separately) \" option. It creates a directory with a xsetup file to execute that you can reuse in case of failure during the installation Execute ./xsetup Choose to install Vitis (it will still install Vivado , Vitis , and Vitis HLS ). It will need 110GB of disk space : if you uncheck Ultrascale , Ultrascale+ , Versal ACAP and Alveo acceleration platform , it will use less space and still work. Agree with everything and choose a directory to install (e.g. ~/Xilinx) Install and wait (it may take quite a while) Setup a shell environment variable allowing to use the tools when necessary (add this to your ~/.bashrc , ~/.zshrc or whatever you're currently using, replacing $XILINX_ROOT_DIR by the directory you chose to install all the tools) export XILINX_ROOT_DIR=$HOME/Xilinx","title":"Vivado, Vitis &amp; Vitis HLS (2024.1 version)"},{"location":"manual/dependencies/#installing-cable-drivers-on-linux","text":"cd $XILINX_ROOT_DIR/Vivado/2024.1/data/xicom/cable_drivers/lin64/install_script/install_drivers ./install_drivers # Allow JTAG-USB connection: sudo cp 52-xilinx-digilent-usb.rules /etc/udev/rules.d","title":"Installing Cable Drivers on Linux"},{"location":"manual/dependencies/#installing-digilent-board-files","text":"Download the board files from github : Open the folder extracted from the archive and navigate to its new/board_files folder. You will be copying all of this folder's subfolders For the 2020.2 version , go to $XILINX_ROOT_DIR/Vivado/2020.2/data/boards/board_files For the 2022.2 version and above , go to $XILINX_ROOT_DIR/Vivado/202x.x/data/xhub/boards/XilinxBoardStore/boards/Xilinx Copy all of the folders found in vivado-boards new/board_files folder and paste them into this folder","title":"Installing Digilent Board Files"},{"location":"manual/dependencies/#cloning-the-syfala-repository","text":"To clone and install the latest stable version of the Syfala toolchain, you can use the following commands: git clone https://github.com/inria-emeraude/syfala cd syfala make install syfala --help In order to use the Syfala toolchain to compile your first example, please report to the main README file located in the repository's root directory.","title":"Cloning the Syfala repository"},{"location":"manual/dependencies/#troubleshooting","text":"On Archlinux , if you see an error like this one /lib/../lib64/crti.o: file not recognized: File format not recognized you'll have to rename the Vivado/202x.x/tps/lnx64/binutils-2.26 (Vitis will then search in the system libraries).","title":"Troubleshooting"},{"location":"manual/dependencies/#vitisjava-issues","text":"On recent systems (or with Archlinux ), you might have problems compiling the host-side ( ARM ) application. The problem is caused by system libraries requiring newer versions of GCC than the one provided by Vitis. Replacing GCC target in Vitis' path by system GCC works: cd $XILINX_ROOT_DIR/Vitis/202x.x/lib/lnx64.o/Default mv libstdc++.so.6 libstdc++.so.6.old rm -rf libstdc++.so (symlink) sudo ln -s /usr/lib/libstdc++.so.6 libstdc++.so.6","title":"Vitis/Java issues"},{"location":"manual/dependencies/#installing-the-2022-patch-amd-xilinx-toolchain-v20202-only","text":"Vivado and Vitis tools that use HLS in the background are also affected by this issue. HLS tools set the ip_version in the format YYMMDDHHMM and this value is accessed as a signed integer (32-bit) that causes an overflow and generates the errors below (or something similar). Follow this link: https://support.xilinx.com/s/article/76960?language=en_US Download the file at the bottom of th page and unzip it in $XILINX_ROOT_DIR Run the following commands: cd $XILINX_ROOT_DIR export LD_LIBRARY_PATH=$PWD/Vivado/2020.2/tps/lnx64/python-3.8.3/lib/ Vivado/2022.2/tps/lnx64/python-3.8.3/bin/python3 y2k22_patch/patch.py","title":"Installing the 2022 patch (AMD-Xilinx toolchain v2020.2 only)"},{"location":"manual/dependencies/#_1","text":"","title":""},{"location":"manual/reference/","text":"Command-line interface reference General options name description arguments -x --xilinx-root sets XILINX_ROOT_DIR for the current build path --xversion sets XILINX_VERSION for the current build 2020.2|2022.2* --board, -b Defines the target board: Digilent Zybo Z7-10/20 or Genesys ZU-3EG Z10*|Z20|GENESYS Commands name description arguments tidy removes all temporary files generated by the toolchain none clean deletes current build directory none reset deletes current build directory as well as the syfala_log & resets the current toolchain configuration none import sets previously exported .zip build as the current build path to the .zip build export exports current build in a .zip file located in the 'export' directory name of the build report displays HLS or global report log displays the current build's full log none test builds & runs all toolchain tests none flash flashes current build onto target device none start-gui executes the Faust-generated GUI application none open-project opens the generated .xpr project with Vivado help prints list of available commands, options and run-time parameters none version displays the current script's version none Build options name description --linux builds the embedded linux if doesn't already exist and exports the build in the root partition ( /home/syfala/mybuild ) --midi adds MIDI control for the Faust GUI and/or the Embedded Linux Control Application --osc adds OSC control for the Faust GUI and/or the Embedded Linux Control Application --http adds HTTP control for the Faust GUI and/or the Embedded Linux Control Application Design options name arguments description --multisample power of two integer (e.g. 16, 24, 32, etc. ) DSP block will compute a block of samples instead of a single one. This may improve overall throughput but will introduce audio i/o latency. --sigma-delta none Builds the project with a sigma-delta dac configuration ( experimental ) --tdm none Builds the project with i2s TDM ( experimental ) --ethernet none ( linux only ) uses tcp/ip ethernet to convey input/output signals from & to faust HLS options name arguments description --accurate-use none Runs HLS with the impl flow, shows more accurate resources/latency reports, but takes longer to run. --csim path to simulation .cpp file Runs C simulation for the syfala DSP IP --csim-iter integer (1 to ...) Sets the number of syfala calls during the C simulation --csim-inputs path to directory containing in0.txt / in1.txt etc. Set the directory containing input samples files (as .txt files). Each sample should be normalized floating point values going from -1.f to 1.f separated by a white space or a line return. --mcd none ( faust only ) Max-copy-delay: threshold between copy and ring buffer implementation (default 16). --unsafe-math-optimizations --umo Adds the Vitis HLS unsafe_math_optimizations directive to the syfala DSP IP. --hls-flags Tcl string n/a ARM options name arguments description --shield adau|motherboard Adds support for ADAU1777 / ADAU1787 external codecs, or for the ADAU Motherboard --benchmark none ( faust only ) Enables benchmark for the ARM control-loop. --verbose none n/a --arm-target path to .cpp file Selects the main (.cpp) source file for the ARM control application. --controller-type DEMO|PCB1*|PCB2|PCB3|PCB4|TEENSY Defines the controller used to drive the controls when SW3 is UP. --ssm-volume FULL|HEADPHONE*|DEFAULT ( Zybo boards only ) HEADPHONE : lower volume for headphone use. DEFAULT : default value +1dB, the true 0dB ( 0b001111001 ) decreases the signal a little bit. --ssm-speed FAST|DEFAULT* ( Zybo boards only ) changes SSM ADC/DAC sample rate. DEFAULT : 48kHz sample rate. FAST : 96Khz sample rate Run steps Note : the --all is not necessary if you wish to run all steps, just run syfala myfaustdsp.dsp --all runs all toolchain compilation steps (from --sources to --gui ) --sources uses Faust to generate ip/host cpp files for HLS and Host application compilation --hls runs Vitis HLS on generated ip cpp file --project generates Vivado project --synth synthesizes full Vivado project --host compiles Host application, exports sources and .elf output to build/sw_export --gui compiles Faust GUI control application --flash flashes boot files on device at the end of the run --report prints HLS report at the end of the run --export <id> exports build to export/ directory at the end of the run Run parameters parameter accepted values description default value --memory, -m DDR - STATIC ( faust only ) Choose between DDR & static memory layout for faust delay-lines, rd/rwtables. DDR --sample-rate 48000 - 96000 - 192000 - 384000 - 768000 Changes sample rate value (Hz). Only 48kHz and 96kHz is available for SSM embeded codec. 192000 ( ADAU1777 and ADAU1787 only) 384000 ( ADAU1787 only) 768000 ( ADAU1787 only and with --sample--width 16 only) 48000 --sample-width 16 - 24 - 32 Defines sample bit depth (16|24|32) 16 Hardware configuration (Zybo Z7-10/20) Syfala Hardware Controller Board (SW3 UP) If you use a Hardware Controller Board, please set the --controller-type command-line parameter to the proper value (see below) Controller-type values description DEMO : Popophone demo box PCB1 : Emeraude PCB config 1: 4 knobs, 2 switches, 2 sliders (default) PCB2 : Emeraude PCB config 2: 8 knobs PCB3 : Emeraude PCB config 3: 4 knobs, 4 switches PCB4 : Emeraude PCB config 4: 4 knobs above, 4 switches below TEENSY : Teensy-based controller. You can swap from hardware to software controller during DSP execution by changing SW3 . Switch description Default configuration in bold SW3 SW2 SW1 SW0 +-----+-----+-------+------+ | Hard| ADAU| BYPASS| MUTE | | | | | | | | | | | | GUI | SSM | USE DSP | UNMUTE | +-----+-----+-------+------+ SW3 : Controller type select: hardware (Controller board) or software (GUI). SW2 : Audio codec input select (ADAU=external or SSM=onboard). Does not affect output. SW1 : Bypass audio dsp. SW0 : Mute. Status LEDs The RGB led indicate the program state: BLUE : waiting GREEN : all good! ORANGE : warning (bypass or mute enabled) RED : ERROR! (configuration failed or incompatible), could happen if you select the SSM codec with incompatible sample rate. The 4 LEDs above the switches indicate the switches state. If one of them blink, it indicates the source of the warning/error. SD card files (baremetal configuration) You can put the program on an SD card (if you want something reproducible and easily launchable, for the demos...). After a make command, you should see a BOOT.bin file in SW_export (or you can build it with make boot_file ). Put the file on the root of SD card. And don't forget to put JP5 on 'SD' position !","title":"Reference"},{"location":"manual/reference/#command-line-interface-reference","text":"","title":"Command-line interface reference"},{"location":"manual/reference/#general-options","text":"name description arguments -x --xilinx-root sets XILINX_ROOT_DIR for the current build path --xversion sets XILINX_VERSION for the current build 2020.2|2022.2* --board, -b Defines the target board: Digilent Zybo Z7-10/20 or Genesys ZU-3EG Z10*|Z20|GENESYS","title":"General options"},{"location":"manual/reference/#commands","text":"name description arguments tidy removes all temporary files generated by the toolchain none clean deletes current build directory none reset deletes current build directory as well as the syfala_log & resets the current toolchain configuration none import sets previously exported .zip build as the current build path to the .zip build export exports current build in a .zip file located in the 'export' directory name of the build report displays HLS or global report log displays the current build's full log none test builds & runs all toolchain tests none flash flashes current build onto target device none start-gui executes the Faust-generated GUI application none open-project opens the generated .xpr project with Vivado help prints list of available commands, options and run-time parameters none version displays the current script's version none","title":"Commands"},{"location":"manual/reference/#build-options","text":"name description --linux builds the embedded linux if doesn't already exist and exports the build in the root partition ( /home/syfala/mybuild ) --midi adds MIDI control for the Faust GUI and/or the Embedded Linux Control Application --osc adds OSC control for the Faust GUI and/or the Embedded Linux Control Application --http adds HTTP control for the Faust GUI and/or the Embedded Linux Control Application","title":"Build options"},{"location":"manual/reference/#design-options","text":"name arguments description --multisample power of two integer (e.g. 16, 24, 32, etc. ) DSP block will compute a block of samples instead of a single one. This may improve overall throughput but will introduce audio i/o latency. --sigma-delta none Builds the project with a sigma-delta dac configuration ( experimental ) --tdm none Builds the project with i2s TDM ( experimental ) --ethernet none ( linux only ) uses tcp/ip ethernet to convey input/output signals from & to faust","title":"Design options"},{"location":"manual/reference/#hls-options","text":"name arguments description --accurate-use none Runs HLS with the impl flow, shows more accurate resources/latency reports, but takes longer to run. --csim path to simulation .cpp file Runs C simulation for the syfala DSP IP --csim-iter integer (1 to ...) Sets the number of syfala calls during the C simulation --csim-inputs path to directory containing in0.txt / in1.txt etc. Set the directory containing input samples files (as .txt files). Each sample should be normalized floating point values going from -1.f to 1.f separated by a white space or a line return. --mcd none ( faust only ) Max-copy-delay: threshold between copy and ring buffer implementation (default 16). --unsafe-math-optimizations --umo Adds the Vitis HLS unsafe_math_optimizations directive to the syfala DSP IP. --hls-flags Tcl string n/a","title":"HLS options"},{"location":"manual/reference/#arm-options","text":"name arguments description --shield adau|motherboard Adds support for ADAU1777 / ADAU1787 external codecs, or for the ADAU Motherboard --benchmark none ( faust only ) Enables benchmark for the ARM control-loop. --verbose none n/a --arm-target path to .cpp file Selects the main (.cpp) source file for the ARM control application. --controller-type DEMO|PCB1*|PCB2|PCB3|PCB4|TEENSY Defines the controller used to drive the controls when SW3 is UP. --ssm-volume FULL|HEADPHONE*|DEFAULT ( Zybo boards only ) HEADPHONE : lower volume for headphone use. DEFAULT : default value +1dB, the true 0dB ( 0b001111001 ) decreases the signal a little bit. --ssm-speed FAST|DEFAULT* ( Zybo boards only ) changes SSM ADC/DAC sample rate. DEFAULT : 48kHz sample rate. FAST : 96Khz sample rate","title":"ARM options"},{"location":"manual/reference/#run-steps","text":"Note : the --all is not necessary if you wish to run all steps, just run syfala myfaustdsp.dsp --all runs all toolchain compilation steps (from --sources to --gui ) --sources uses Faust to generate ip/host cpp files for HLS and Host application compilation --hls runs Vitis HLS on generated ip cpp file --project generates Vivado project --synth synthesizes full Vivado project --host compiles Host application, exports sources and .elf output to build/sw_export --gui compiles Faust GUI control application --flash flashes boot files on device at the end of the run --report prints HLS report at the end of the run --export <id> exports build to export/ directory at the end of the run","title":"Run steps"},{"location":"manual/reference/#run-parameters","text":"parameter accepted values description default value --memory, -m DDR - STATIC ( faust only ) Choose between DDR & static memory layout for faust delay-lines, rd/rwtables. DDR --sample-rate 48000 - 96000 - 192000 - 384000 - 768000 Changes sample rate value (Hz). Only 48kHz and 96kHz is available for SSM embeded codec. 192000 ( ADAU1777 and ADAU1787 only) 384000 ( ADAU1787 only) 768000 ( ADAU1787 only and with --sample--width 16 only) 48000 --sample-width 16 - 24 - 32 Defines sample bit depth (16|24|32) 16","title":"Run parameters"},{"location":"manual/reference/#hardware-configuration-zybo-z7-1020","text":"","title":"Hardware configuration (Zybo Z7-10/20)"},{"location":"manual/reference/#syfala-hardware-controller-board-sw3-up","text":"If you use a Hardware Controller Board, please set the --controller-type command-line parameter to the proper value (see below)","title":"Syfala Hardware Controller Board (SW3 UP)"},{"location":"manual/reference/#controller-type-values-description","text":"DEMO : Popophone demo box PCB1 : Emeraude PCB config 1: 4 knobs, 2 switches, 2 sliders (default) PCB2 : Emeraude PCB config 2: 8 knobs PCB3 : Emeraude PCB config 3: 4 knobs, 4 switches PCB4 : Emeraude PCB config 4: 4 knobs above, 4 switches below TEENSY : Teensy-based controller. You can swap from hardware to software controller during DSP execution by changing SW3 .","title":"Controller-type values description"},{"location":"manual/reference/#switch-description","text":"Default configuration in bold SW3 SW2 SW1 SW0 +-----+-----+-------+------+ | Hard| ADAU| BYPASS| MUTE | | | | | | | | | | | | GUI | SSM | USE DSP | UNMUTE | +-----+-----+-------+------+ SW3 : Controller type select: hardware (Controller board) or software (GUI). SW2 : Audio codec input select (ADAU=external or SSM=onboard). Does not affect output. SW1 : Bypass audio dsp. SW0 : Mute.","title":"Switch description"},{"location":"manual/reference/#status-leds","text":"The RGB led indicate the program state: BLUE : waiting GREEN : all good! ORANGE : warning (bypass or mute enabled) RED : ERROR! (configuration failed or incompatible), could happen if you select the SSM codec with incompatible sample rate. The 4 LEDs above the switches indicate the switches state. If one of them blink, it indicates the source of the warning/error.","title":"Status LEDs"},{"location":"manual/reference/#sd-card-files-baremetal-configuration","text":"You can put the program on an SD card (if you want something reproducible and easily launchable, for the demos...). After a make command, you should see a BOOT.bin file in SW_export (or you can build it with make boot_file ). Put the file on the root of SD card. And don't forget to put JP5 on 'SD' position !","title":"SD card files (baremetal configuration)"},{"location":"tutorials/cpp-tutorial-advanced/","text":"Using syfala with C++ Introduction While Faust is undoubtedly a nice and easy way to create complex and fully-controllable DSP programs on FPGAs, in some cases - where for instance balancing resource usage and latency becomes a critical issue - bypassing Faust and programming directly in C++ can become a more suitable solution. How does it work? Ordinarily, the easiest way to get started with syfala is to use Faust to generate the C++ code that is going to be fed to the High Level Synthesis ( HLS ) tool and turned into Hardware Description Language (HDL) code. The resulting DSP kernel (or IP : Intellectual Property) is then going to be added to a more global design , which will include the processing system (PS), our custom-made Integrated Interchip Sound ( i\u00b2s ) and various other modules as well. Consequently - and since we're already using HLS - programming the DSP kernel directly in C++ is entirely possible, but remains a more complex solution, and won't offer the same user-friendly features that Faust is able to provide out-of-the-box. Pros: Better balance control between FPGA resource usage & latency . HLS-friendly/optimized code. HLS libraries, pragmas & tools. Cons: Limited support of C++ features (up to C++14 ). Complex HLS interfaces & documentation. No out-of-the-box GUI/Serial control interface. Data exchange with ARM through AXI-Lite or DDR memory has to be done manually. Code structure The following describes how to program a syfala DSP kernel using C++. It is intended for advanced users. Using pre-made examples To get an idea on how to program the DSP kernel in C++, you can refer to the examples/cpp directory in the syfala repository. For this tutorial, we will build a simple stereo gain DSP kernel. The interface that we propose is pretty straightforward, but there a couple of things that still need to be explained in details: Signal types In the global syfala FPGA design, audio signals are conveyed as streams of 24-bits integers, by default . The bit width can be changed using the --sample-width flag in the syfala command line interface, but cannot be changed to single or double precision floating point types. Since audio DSP programs are usually processing float or double -based signals, a few convenience functions and types have been added in the syfala/utilities.hpp header, which can be easily included in your C++ file: #include <syfala/utilities.hpp> This header defines for instance the type sy_ap_int , as the following: // include/syfala/utilities.hpp using sy_ap_int = ap_int<SYFALA_SAMPLE_WIDTH>; // note: the 'ap_int' (arbitrary precision integer) type is defined by Vitis_HLS in $XILINX_ROOT_DIR/Vitis_HLS/2022.2/include/ap_int.h It also defines the following read/write convenience functions between sy_ap_int and float types. These will come in handy when reading and writing from/to the audio input/output ports. // include/syfala/utilities.hpp namespace Syfala::HLS { /** * @brief ioreadf Read sy_ap_int as float * @param input sy_ap_int data input * @return floating-point conversion of input */ float ioreadf(sy_ap_int const& input); /** * @brief iowritef write floating point data to ap_int * top-level function output. * @param f float data input * @param output ap_int interface output. */ void iowritef(float f, sy_ap_int& output); } You should also be able, from this file, to access some useful compile-time data, such as the current sample rate , or sample-width which are defined with the following macros : #define SYFALA_SAMPLE_RATE 48000 #define SYFALA_SAMPLE_WIDTH 24 Audio inputs & outputs First, in order to generate the block design that is going to be synthesized by Vivado and make the proper connections with i\u00b2s , syfala needs to be explicitly informed of the number of audio input/output channels that the DSP program is going to have. In our case, for the stereo gain example, we want 2 inputs and 2 outputs . To do so, in the current version of syfala , the following C macros need to be defined somewhere in the code: // examples/cpp/templates/gain.cpp #define INPUTS 2 #define OUTPUTS 2 It will inform the toolchain to use the following audio input and output ports , which will be formatted like this in our final design: audio_in_# (in our case, audio_in_0 and audio_in_1 ) audio_out_# (in our case, audio_out_0 and audio_out_1 ) Top-level interface The top-level function is the DSP kernel 's' entrypoint, which, in the final block design , will be connected to other peripherals, such as the i\u00b2s and the processing system , with the help of various bus interfaces (AXI, AXI-Lite). Its arguments should be considered as a list of input & output ports , with: pointer arguments being output arguments (or both input & output arguments) non-pointer arguments being input arguments only. array arguments can be both. It's signature should always be void syfala(...) : // examples/cpp/templates/gain.cpp /* Top-level interface function */ void syfala ( // Audio input/output ports (variable): sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], // The following arguments are required and should not be changed: int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ) { [...] Again, each audio input & output arguments have to be formatted exactly like the following: void syfala ( // Audio input/output ports (variable): sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], And have to be followed by these exact same arguments (which we will present in the next sections): // The following arguments are required and their respective names should not be changed: int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ) { [...] Below, the HLS interface pragmas should also remain the same, they're here to indicate to Vitis HLS two things: to split the input/output audio arguments into individual ports (which will be named audio_in_0 , audio_in_1 , audio_out_0 , audio_out_1 ) to map some of the top-level arguments to AXI and AXI-Lite bus interfaces (which will be further explained later). #pragma HLS array_partition variable=audio_in type=complete #pragma HLS array_partition variable=audio_out type=complete #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram Initialization Waiting for ARM initialization Since the DSP kernel and the ARM are not synchronized at a sample-rate level , and the ARM has to first initialize a few peripherals (audio codecs, GPIOs, UART...) before being able to do anything else, it is necessary for the DSP kernel to wait for the arm_ok signal to be received before doing any initialization or processing. Once the ARM is ready, the initialization routine can be done manually with, for example, a static initialization variable. In our stereo gain example, we do: static bool initialization = true; [...] /* Initialization and computations can start after the ARM * has been initialized */ if (arm_ok) { /* First function call: initialization */ if (initialization) { // Initialize all runtime data here. // don't forget to toggle the variable off initialization = false; } else { Bypass/mute switches In all standard syfala designs , the bypass and mute ports of a DSP kernel are pre-mapped to SW0 and SW1 in Zybo Z10/Z20 boards. You can choose to acknowledge and process them if you want: } else { /* Every other iterations: * either process the bypass & mute switches... */ if (bypass) { audio_out[0] = audio_in[0]; audio_out[1] = audio_in[1]; } else if (mute) { audio_out[0] = 0; audio_out[1] = 0; } else { DSP code Finally, here is an example of a processing function taking advantage of the Syfala::HLS::ioreadf() and Syfala::HLS::iowritef() convenience functions in order to switch back & forth between float and sy_ap_int types. } else { /* ... or compute samples here */ compute(audio_in, audio_out); } For our stereo gain example, we first convert the input data to float , multiply it by 0.5f and write it back to the output ports . static void compute(sy_ap_int const inputs[], sy_ap_int outputs[]) { // if you need to convert to float, use the following: // (audio inputs and outputs are 24-bit integers by default) float f0 = Syfala::HLS::ioreadf(inputs[0]) * 0.5f; float f1 = Syfala::HLS::ioreadf(inputs[1]) * 0.5f; Syfala::HLS::iowritef(f0, outputs[0]); Syfala::HLS::iowritef(f1, outputs[1]); } Building and flashing with the syfala CLI syfala works the same way with C++ targets, you'll only need to replace the Faust .dsp target with your .cpp file in the command line. We can now try to synthesize our stereo gain DSP kernel , in order to see if our code compiles: syfala examples/cpp/templates/gain.cpp --board Z20 --hls Once the high-level synthesis is done, syfala should display the Vitis HLS estimate of the kernel's latency and resource utilization : DSP 2% (6) FF ~0% (997) LUT 3% (2070) BRAM 0% (0) Latency: Tot. 47 Cycles 0.382us Verifying code with C simulation (CSIM) We know now that our code compiles, but we won't be able to test it until the full Vivado synthesis & implementation are done, which, depending on your machine, can take up some time. We'll then have to flash the device, connect an audio-input and a headset to the board, and see if the stereo gain in our example is properly applied. Needless to say, the process is a bit long and tedious. You don't really want to go through all of that too many times when you're debugging code, and that's precisely where C simulation ( CSIM ) comes into play. C simulation is an important Vitis HLS feature, which allows you to test your C-written kernel without having to get through the full synthesis process. In short: Vitis HLS guarantees (with a few exceptions) that the outputs of your kernel is going to be the same as they would be in a real context of execution. Using pre-defined generic templates: Now, if we get back to our stereo gain example, and since it is a really simple one, we will take advantage of the generic CSIM C++ template that is available in the syfala source tree (located in tests/csim/csim_cpp_template.cpp ). Here's an example of command that can be used: syfala examples/cpp/templates/gain.cpp --csim tests/csim/csim_cpp_template.cpp --csim-inputs tests/stimuli --csim-iter 64 # output results will be stored in reports/csim/gain/out0.txt & reports/csim/gain/out1.txt Where: --csim tests/csim/csim_cpp_template.cpp - the simulation test file. --csim-inputs tests/stimuli - we specify using the tests/stimuli directory to fetch input samples. tests/stimuli contains two .txt files, named in0.txt and in1.txt and are filled with normalized ( -1.f to 1.f ) floating point values. --csim-iter 64 - the DSP kernel will be called 64 times (64 samples). We can finally verify the outputs of our stereo gain kernel, by comparing the input stimuli files with the output files (output samples should be input/2 ). Writing your own CSIM While the generic template will work for simple DSP kernels that have the same top-level function signature, you will have to write your own CSIM file to validate kernels that have more complex interfaces. In order to do this, and since the generic template is scripted and a bit complicated to read, let's take inspiration from the csim_cpp_template_gain.cpp example file, and see what it is actually doing: We first declare the syfala top-level function prototype , which is going to have the exact same signature as in our gain.cpp file. // tests/csim/csim_cpp_template_gain.cpp void syfala ( sy_ap_int audio_in[2], sy_ap_int audio_out[2], int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ); We then instantiate and pre-initialize the values that are going to be passed to the syfala function arguments : sy_ap_int audio_in[2] = {0, 0}; sy_ap_int audio_out[2] = {0, 0}; // Here, we simulate having the ARM initialized and ready, by setting the 'arm_ok' variable to 'true': int arm_ok = true; // The i2s is not part of the simulation, so this really doesn't matter: bool i2s_rst = false; // We don't use DDR memory, nor the bypass/mute switches: set everything to zero: float* mem_zone_f = nullptr; int* mem_zone_i = nullptr; bool bypass = false; bool mute = false; bool debug = false; We also instantiate float type copies of inputs and outputs, for setting random input values, and printing outputs. float f_inputs[2] = {0, 0}; float f_outputs[2] = {0, 0}; Then, call the syfala function with all the proper arguments. // For each simulation iteration (set with the '--csim-iter' flag) for (int i = 0; i < SYFALA_CSIM_NUM_ITER; i++) { if (i > 0) { // first iteration = initialization, inputs will be ignored // wait for second iteration. f_inputs[0] = (float)rand()/RAND_MAX; f_inputs[1] = (float)rand()/RAND_MAX; } Syfala::HLS::iowritef(f_inputs[0], audio_in[0]); Syfala::HLS::iowritef(f_inputs[1], audio_in[1]); // call top-level function syfala(audio_in, audio_out, arm_ok, &i2s_rst, mem_zone_f, mem_zone_i, bypass, mute, debug ); [...] } Once it is done, fetch and print the input/output samples (as float) : [...] f_outputs[0] = Syfala::HLS::ioreadf(audio_out[0]); f_outputs[1] = Syfala::HLS::ioreadf(audio_out[1]); printf(\"[ch0] input: %f, result: %f\\n\", f_inputs[0], f_outputs[0]); printf(\"[ch1] input: %f, result: %f\\n\", f_inputs[1], f_outputs[1]); } Optimizing code For simple examples, such as our previous stereo-gain kernel , there's obviously not going to be an immediate and imperative need for optimization. Consequently, we will this time get our hands on something a little more resource and computation hungry . In audio digital signal processing, FIR filters are encountered on a very regular basis, and, depending on the number of coefficients that they have, they can be tricky to implement on FPGAs, especially if no optimizations are made. Let's have a look at our examples/cpp/fir/fir.cpp example: #include \"coeffs.hpp\" static float coeffs[] = { 0.000000000000000000, -0.000000914435621961, 0.000000000000000000, 0.000008609100789076, [...] }; #define INPUTS 0 #define OUTPUTS 2 #define NCOEFFS 115 static float samples[NCOEFFS]; static float sawtooth; float compute_fir() { float out = 0; samples[0] = sawtooth; for (int n = 0; n < NCOEFFS; ++n) { out += mem[n] * coeffs115[n]; } for (int j0 = NCOEFFS-1; j0 > 0; --j0) { mem[j0] = samples[j0-1]; } sawtooth += 0.01f; sawtooth = fmodf(sawtooth, 1.f); return out; } In this example, we first statically define a bunch of FIR coefficients in the examples/cpp/fir/coeffs.hpp header, as well as a zero-initialized array ( samples[NCOEFFS] ), which will be used to store the previous samples. The compute_fir function generates a really basic phasor/sawtooth signal , and feed it into the FIR filter. Once all the samples are computed for NCOEFFS , we shift the samples[] array by one in the right direction. Then, as in our previous examples, we call the ' compute ' function from the syfala top-level function. In this case, we are going to write the same signal on both left and right output channels. /* ... or compute samples here * if you need to convert to float, use the following: * (audio inputs and outputs are 24-bit integers) */ float f = compute_fir(); Syfala::HLS::iowritef(f, audio_out[0]); Syfala::HLS::iowritef(f, audio_out[1]); Monitoring latency & resource utilization Now, in order to evaluate the program's performance and efficiency, the first thing that we can do is run the High Level Synthesis step and carefully read the output results . This can be done using the following command: syfala examples/cpp/fir/fir.cpp --board Z10 --hls which is going to give us this estimate : fir.cpp Z10 48000 24 (Vitis HLS estimate) 115 coefficients - DSP: 8% (7) - Reg: 5% (1829) - LUT: 20% (3617) - BRAM: 2% (3) Tot. 1057 Cycles, 8.602us Max. 2559 Cycles, 20,8333us Lat. 41% Needless to say, even for a Zybo Z7-10 , this is not really satisfying: if we project ourselves linearly , it means that we could probably only fit at best a 300 coefficients FIR filter or so without reaching the maximum sample latency . Let's try it out with 300 coefficients now: fir.cpp Z10 48000 24 (Vitis HLS estimate) 300 coefficients - DSP: 8% (7) - Reg: 5% (1837) - LUT: 20% (3619) - BRAM: 2% (4) Tot. 2722 Cycles, 22.152us Max. 2559 Cycles, 20,8333us Lat. 106% With a 300-coefficients filter , we even actually go a little bit above max latency . On the other hand, we can see that the resources stay pretty much the same as before, so there's probably room for improvement here in terms of balance between latency & resource utilization, and the first thing we can do to remedy this problem would maybe be to use some of the Vitis HLS C/C++ pragmas . Using optimization directives & pragmas Now, what we really want Vitis HLS to do here, for the latency to drop down, would be to parallelize the computations a bit more. If we go through Vitis HLS documentation , there are a couple of things that can be tried in order to do that, without modifying the code too much. Our first choice here would be to use the unroll #pragma , which could introduce more parallelization in our accumulation loop : float compute_fir() { float out = 0; mem[0] = sawtooth; for (int n = 0; n < NCOEFFS; ++n) { #pragma HLS UNROLL out += mem[n] * coeffs[n]; } [...] If we try to run HLS with this code, we see that pretty much nothing happens (the results may even be worse than before). That's because this particular accumulation loop cannot really be parallelized without using what we call a balanced tree (in our case, an 'adder tree'). By default, Vitis HLS does not automatically make this optimization for floating-point operations, but it can be enabled using the --unsafe-math-optimizations (or --umo ) flag in the syfala command line: syfala examples/cpp/fir/fir300.cpp --hls --umo Let's now try to see what it's giving us for our 300 coefficients example: fir.cpp Z10 48000 (Vitis HLS estimate) 300 coefficients - DSP: 31% (25) - Reg: 18% (6532) - LUT: 66% (3619) - BRAM: 1% (2) Tot. 529 Cycles, 4.536us Max. 2559 Cycles, 20,8333us Lat. 20% The results are definitely more reasonable in terms of latency. On the other hand, we can see that the resources ( LUTs in particular) have increased a lot. If we push it a little bit more, let's say with 600 coefficients this time, this is what we get: fir.cpp Z10 48000 (Vitis HLS estimate) 600 coefficients - DSP: 31% (25) - Reg: 23% (8101) - LUT: 85% (15019) - BRAM: 1% (2) Tot. 987 Cycles, 8.537us Max. 2559 Cycles, 20,8333us Lat. 38% With 600 coefficients , we're still okay on latency, but the Lookup Table ( LUT ) number is now getting dangerously high . Remember: the numbers shown on these reports are only an estimate , which means that this number could be in reality a bit higher, introducing the risk that our kernel might not actually fit on the Zybo Z7-10 board. Accurate reports In a situation like this one, it is usually a good idea to tell Vitis HLS that we need a more accurate report on the allocated resources. Adding the --accurate-use flag to the syfala command line will do exactly that for us: syfala examples/cpp/fir300.cpp --hls --umo --accurate-use This will tell Vitis HLS to run both the synthesis and implementation steps on the DSP kernel only (not on the final design). It usually takes more time (approximately 5 to 10 minutes, depending on the kernel), but it will give precise and valuable information on the resources that will be used on the board: GUIDELINE - DSP: 31% (25) OK (80%) - Reg: 22% (7912) OK (50%) - LUT: 70% (12332) WARNING (70%) - BRAM: 1% (2) OK (80%) If we now look at the GUIDELINE column, we can see that we have indeed a WARNING on the LUT section, which basically means that the design may not fit on the board. But instead of trying to run the full synthesis and hope for the best, maybe we can tweak the pragmas a little more, to give ourselves a safer margin. Vitis HLS documentation tells us that we can add to the UNROLL pragma ** a parameter called factor , which basically represents the level of parallelization that we want to introduce in the loop. When this parameter is not explicitly set , Vitis HLS will fully unroll the loop , which might explain why the number of LUTs has sky-rocketted in our previous examples. If we tune this factor with a lower number, it might help bring down the utilization of this specific FPGA resource. Let's try it now with a factor** 10 , and see what it does: float compute_fir() { [...] for (int n = 0; n < NCOEFFS; ++n) { #pragma HLS UNROLL factor=10 out += samples[n] * coeffs[n]; } [...] Which is going to give us: fir.cpp Z10 48000 (Vitis HLS estimate) 600 coefficients - DSP: 15% (12) - Reg: 9% (3452) - LUT: 28% (4966) - BRAM: 3% (4) Tot. 1139 Cycles, 9.269us Max. 2559 Cycles, 20,8333us Lat. 44% This is starting to get a lot better, and if we go up to 1000 coefficients now: fir.cpp Z10 48000 (Vitis HLS estimate) 1000 coefficients - DSP: 15% (12) - Reg: 9% (3452) - LUT: 28% (4966) - BRAM: 3% (4) Tot. 1859 Cycles, 15.129us Max. 2559 Cycles, 20,8333us Lat. 72% The results here are getting really interesting, since we can clearly see that the resources used are exactly the same as our 600 coefficients example. Latency is the only thing that has increased, from 44% to 72%, which remains a somewhat comfortable margin. Using a 'sample block' configuration (--multisample) Another method that can be used in order to balance latency and resource utilization would be for the DSP kernel to process a block of samples instead of a single one, i.e. to ' bufferize ' the signal to maximize efficiency and parallelization. Not unlike CPUs, this may also result in better FPGA resource dispatch and/or throughput, but has on the other hand the drawback of introducing I/O latency . Syfala supports sample block processing for both Faust and C++ targets, by adding the --multisample <N> flag: syfala examples/cpp/templates/gain-multisample.cpp --multisample 16 --hls For C++ targets, the code needs to be adapted a bit, since we now have FIFO arrays as inputs and outputs, we have to declare them as C multidimensional arrays , like the following: void syfala ( sy_ap_int audio_in[INPUTS][SYFALA_BLOCK_NSAMPLES], sy_ap_int audio_out[OUTPUTS][SYFALA_BLOCK_NSAMPLES], [...] #pragma HLS INTERFACE ap_fifo port=audio_in #pragma HLS INTERFACE ap_fifo port=audio_out #pragma HLS array_partition variable=audio_in type=complete #pragma HLS array_partition variable=audio_out type=complete #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram Within the top-level function, this also changes the way we have to process the bypass/mute switches : } else { /* Every other iterations: * either process the bypass & mute switches... */ if (bypass) { for (int n = 0; n < OUTPUTS; ++n) { for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { audio_out[n][m] = audio_in[n][m]; } } } else if (mute) { for (int n = 0; n < OUTPUTS; ++n) { for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { audio_out[n][m] = 0; } } And finally our compute function : } else { /* ... or compute samples here */ compute(audio_in, audio_out); } // examples/cpp/templates/gain-multisample.cpp static void compute( sy_ap_int const inputs[INPUTS][SYFALA_BLOCK_NSAMPLES], sy_ap_int outputs[OUTPUTS][SYFALA_BLOCK_NSAMPLES] ) { for (int n = 0; n < OUTPUTS; ++n) for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { // if you need to convert to float, use the following: // (audio inputs and outputs are 24-bit integers by default) float f = Syfala::HLS::ioreadf(inputs[n][m]) * 0.5f; Syfala::HLS::iowritef(f, outputs[n][m]); } } } FIR example Let's get back to our FIR example, in order to see what can be done to optimize things a bit more. An unoptimized multisample example can be found in examples/cpp/fir/fir-multisample.cpp . Let's see what kind of results we get with a block of size 16 and 300 coefficients : syfala examples/cpp/fir/fir-multisample.cpp --board Z10 --multisample 16 --hls fir-multisample.cpp Z10 48000 (Vitis HLS estimate) block size: 16 samples 300 coefficients - DSP: 8% (7) - Reg: 5% (1935) - LUT: 21% (3829) - BRAM: 3% (4) Tot. 43585 Cycles, 0.355ms Per sample: 2724 Cycles. Max. 2559 Cycles, 20,8333us Lat. 106% Compared to our unoptimized 'one-sample' FIR example with the same number of coefficients , and considering we also introduce an I/O latency of 16 samples (about 0.3 milliseconds), we can say with confidence that this is not really good, and that's essentially because - if we carefully look at the more advanced reports that Vitis HLS is giving us - the samples are still processed sequentially , which is not going to introduce a lot of changes compared to the single-sample version. Consequently, even if we unroll our accumulation loop as we did before, the results are also going to be more or less the same. [...] CSIM with --multisample configuration: syfala examples/cpp/templates/gain-multisample.cpp --multisample 32 --csim tests/csim/csim_cpp_template_multisample.cpp --csim-inputs tests/stimuli --csim-iter 5 # output results will be stored in reports/csim/gain-multisample/out0.txt & reports/csim/gain-multisample/out1.txt Sharing processing/control with the ARM executable Since the resources on a FPGA are far from being infinite, it is usually preferable to use a custom ARM executable for some specific use-cases, such as: Initialization of constants , wavetables ... Long delay-lines (stored/initialized in DDR memory). Control-rate computations. etc. This is exactly what syfala does under the hood with Faust programs : control-rate expressions, resulting from the sliders/button being interacted with, are for instance made on the ARM, and shared through a memory bus called AXI-Lite . The following example shows how we can implement a similar (though simpler) control-rate gain parameter, which we will be able update on the console and share with the DSP kernel. Basic AXI-Lite control example This example, which you can find in examples/cpp/templates/gain-control-hls.cpp , is almost exactly the same as our previous gain.cpp example. The only difference is that we want to make variable the gain parameter that we hardcoded to 0.5f before. All we basically need to do here is to introduce a new floating-point argument gain in the top-level function , which will also be declared as an AXI-Lite interface port using the appropriate pragma : void syfala ( sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], [...] float gain ) { [...] #pragma HLS INTERFACE s_axilite port=gain For the rest of the code, we simply add gain to the compute() function's arguments, and then apply it to the inputs. } else { /* ... or compute samples here */ compute(audio_in, audio_out, gain); } static void compute(sy_ap_int const inputs[], sy_ap_int outputs[] float gain) { float f0 = Syfala::HLS::ioreadf(inputs[0]) * gain; float f1 = Syfala::HLS::ioreadf(inputs[1]) * gain; Syfala::HLS::iowritef(f0, outputs[0]); Syfala::HLS::iowritef(f1, outputs[1]); } That's it! On the HLS side of things, it remains pretty simple. On the ARM side , it gets unfortunately a bit more complicated, as we are going to see now :-) DSP kernel drivers We already know that Vitis HLS is going to take our gain-control-hls.cpp file and generate the VHDL-equivalent, which is then going to be integrated in our final design. But it's not the only thing that it does: among other things, it also generates 'drivers' for interacting with the kernel from the ARM . Let's first synthesize our DSP kernel with Vitis HLS, and take a look at some of the files that are generated in the build directory: syfala examples/cpp/templates/gain-control-hls.cpp --hls If we now go in the build/syfala_ip/syfala/impl/ip/drivers/syfala_v1_0/src directory, we see that a Makefile and some C files have been generated , specifically: - xsyfala.c - xsyfala.h - xsyfala_hw.h - xsyfala_linux.c - xsyfala_sinit.c We're not going to go into details about each file: the one that is truly interesting to us in the context of our example is the xsyfala.h C header . If we open this file , we see that the following function prototypes are declared: void XSyfala_Set_arm_ok(XSyfala *InstancePtr, u32 Data); u32 XSyfala_Get_arm_ok(XSyfala *InstancePtr); void XSyfala_Set_mem_zone_f(XSyfala *InstancePtr, u64 Data); u64 XSyfala_Get_mem_zone_f(XSyfala *InstancePtr); void XSyfala_Set_mem_zone_i(XSyfala *InstancePtr, u64 Data); u64 XSyfala_Get_mem_zone_i(XSyfala *InstancePtr); void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data); u32 XSyfala_Get_gain(XSyfala *InstancePtr); You can see that these functions' names match some of the arguments that we put in the top-level function. That's because these arguments are already registered as AXI or AXI-Lite interface arguments in our DSP kernel code : void syfala ( [...] int arm_ok, float* mem_zone_f, int* mem_zone_i, float gain ) { #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE s_axilite port=gain #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram In our case, since the other arguments arm_ok , mem_zone_f and mem_one_i are already taken of by syfala , the one that is going to be useful to us is the gain parameter, and, specifically, its 'setter' function : void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data) Writing the ARM executable In order to code the executable that is going to run on the ARM, we will take the code from source/arm/baremetal/arm_minimal.cpp , which contains all that is necessary for the application to run properly, and we are going to add our gain control function . The result can be seen in examples/cpp/templates/gain-control-arm.cpp . In our update_gain() function, we are simply going to fetch a new gain value using scanf , and update it on the FPGA using the XSyfala_Set_gain driver function : static void update_gain(XSyfala& syfala) { static float gain = 1.f; printf(\"Enter gain value (from 0.f to 1.f)\\r\\n\"); scanf(\"%f\", &gain); printf(\"Gain: %f\\r\\n\", gain); XSyfala_Set_gain(&syfala, *reinterpret_cast<u32*>(&gain)); } Note : floating-point data have to be set using reinterpret_cast<u32*> , otherwise, it will be interpreted as an integer and truncated. In the main() function, all we have to do now is call our update_gain() function in the main event loop , passing it the XSyfala handle struct . int main(int argc, char* argv[]) { XSyfala syfala; UART::data uart; // UART & GPIO should be initialized first, // i.e. before outputing any information on leds & stdout. GPIO::initialize(); UART::initialize(uart); // Wait for all peripherals to be initialized Status::waiting(RN(\"[status] Initializing peripherals & modules\")); Audio::initialize(); IP::initialize(syfala); IP::set_arm_ok(&syfala, true); Status::ok(RN(\"[status] Application ready, now running...\")); // main event loop: while (true) { // -------------------------------------------------------- update_gain(syfala); sleep(1); // -------------------------------------------------------- } return 0; } Running syfala Finally, to fully run syfala on our example , including the ARM executable, we need to add the --arm-target flag to the command line, with the path to our .cpp file as an argument: syfala examples/cpp/templates/gain-control-hls.cpp --arm-target examples/cpp/templates/gain-control-arm.cpp --board Z10 AXI-Lite array arguments It is also entirely possible to pass array arguments to the AXI-Lite bus. On the HLS side, it remains straightforward: void syfala ( sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], [...] float my_control_parameters[64] ) { #pragma HLS INTERFACE s_axilite port=my_control_parameters In the xsyfala.h header, the matching functions generated by Vitis HLS will be the following: u32 XSyfala_Write_my_control_parameters_Words(XSyfala *InstancePtr, int offset, word_type* data, int length); u32 XSyfala_Read_my_control_parameters_Words(XSyfala *InstancePtr, int offset, word_type* data, int length); Which you'll be able to access like in the following example: XSyfala dsp; // Instantiate and initialize a local array float my_control_parameters[64]; for (int n = 0; n < 64; ++n) { my_control_parameters[n] = n; } // Write all of the local array's data to the AXI-Lite bus // using the appropriate function: XSyfala_Write_my_control_parameters_Words ( &dsp, 0, reinterpret_cast<u32*>(my_control_parameters), 64 ); DDR AXI + AXI-Lite control (Embedded Linux and OSC) Let's take a different example this time, and since we haven't really dealt with audio synthesis yet, we will implement a simple wavetable-based sine oscillator , for which its frequency and gain parameter will be remotely controllable with the Open Sound Control protocol, and its wavetable allocated on the DDR ram, initialized on the ARM , and, finally, read from the DSP kernel . You can find the HLS implementation in examples/cpp/templates/osc-synth-hls.cpp and the ARM (Linux) part in examples/cpp/templates/osc-synth-arm.cpp . // examples/cpp/templates/osc-synth-hls.cpp #define INPUTS 0 #define OUTPUTS 2 void syfala ( sy_ap_int audio_out[OUTPUTS], int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug, float frequency, float gain ) { #pragma HLS INTERFACE s_axilite port=frequency #pragma HLS INTERFACE s_axilite port=gain #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram Our DSP kernel HLS code , above and below, is still pretty straightforward here: We add two read-only floating-point parameters frequency and gain to the top-level function arguments, Just like our previous example, we register them to the AXI-Lite bus with the proper pragmas . Then, we're simply going to update and compute the oscillator's phase , and read its wavetable using the mem_zone_f pointer read/write argument. As you may have noticed, this specific argument is registered on the m_axi ( AXI ) bus with a different HLS pragma . } else { /* ... or compute samples here */ static float phase; static int iphase; // Update increment value and the oscillator's phase float incr = frequency/SYFALA_SAMPLE_RATE; iphase = (int)(phase * 16384); phase = fmodf(phase + incr, 1.f); // Read the DDR wavetable at index [iphase] float f = mem_zone_f[iphase]; #ifdef __CSIM__ printf(\"iphase: %d, f: %f\\n\", iphase, f); #endif // Finally, apply gain factor f *= gain; Syfala::HLS::iowritef(f, audio_out[0]); Syfala::HLS::iowritef(f, audio_out[1]); } Note : we fundamentally 'assume' the mem_zone_f variable is directly pointing to the wavetable's start, which we are going to really make sure of in the code that is going to be on the Linux/ARM-side of things. Allocating/initializing the wavetable In the ARM code, we will first retrieve a RAM pointer by calling the Syfala::Memory::initialize() API function, which will give us a pointer to the base of a free portion of DDR memory , which has been pre-reserved when building the Embedded Linux for Syfala. It will also automatically write the address to the AXI bus and the mem_zone_f function argument that we have in our HLS code. Since we only have one wavetable , hence a single memory zone, we can leave things as is (without any offset) and just consider mem.f_zone as the start of our wavetable . Then, we can safely initialize the wavetable . Here, we write a single period of a very basic sinewave . // examples/cpp/templates/osc-synth-arm.cpp #define WAVETABLE_LEN 16384 static float frequency = 440.f, gain = 0.25f; static void initialize_default_values(XSyfala& dsp) { // Initialize AXI-Lite based controls, // the same way that we did in our previous example. XSyfala_Set_frequency(&dsp, *reinterpret_cast<u32*>(&frequency)); XSyfala_Set_gain(&dsp, *reinterpret_cast<u32*>(&gain)); } static void initialize_wavetables(float* mem, int len) { // Write a single period of a sinewave for (int n = 0; n < len; ++n) { mem[n] = std::sin((float)(n)/len * M_PI * 2); } } int main(int argc, char* argv[]) { [...] // The following function will set 'mem.f_zone' pointer // to the base of a free portion of DDR memory Memory::initialize(dsp, mem, 0, WAVETABLE_LEN); // We also initialize 'frequency' and 'gain' parameters to their default value initialize_default_values(dsp); // and finally, initialize the wavetable. initialize_wavetables(mem.f_zone, WAVETABLE_LEN); [...] } OSC control example Since we're using the Embedded Linux in this example, we will take advantage of using the liblo Open Sound Control library , which is installed by default on our Alpine Linux distribution . // examples/cpp/templates/osc-synth-arm.cpp /** * Start a new OSC server thread on port '8888', * register both '/osc/frequency' and '/osc/gain' float parameters * assign them the proper callback functions. */ static void initialize_osc(XSyfala& dsp) { osc = lo_server_thread_new(\"8888\", error_hdl); lo_server_thread_add_method(osc, \"/osc/frequency\", \"f\", osc_frequency_hdl, &dsp); lo_server_thread_add_method(osc, \"/osc/gain\", \"f\", osc_gain_hdl, &dsp); lo_server_thread_start(osc); } static int osc_frequency_hdl ( const char* path, const char* types, lo_arg** argv, int argc, lo_message data, void* udata ){ XSyfala* dsp = static_cast<XSyfala*>(udata); frequency = argv[0]->f; printf(\"[OSC] Updating /osc/frequency with value: %f\\n\", frequency); // Update on the AXI-Lite bus XSyfala_Set_frequency(dsp, *reinterpret_cast<u32*>(&frequency)); return 0; } static int osc_gain_hdl ( const char* path, const char* types, lo_arg** argv, int argc, lo_message data, void* udata ){ XSyfala* dsp = static_cast<XSyfala*>(udata); gain = argv[0]->f; printf(\"[OSC] Updating /osc/gain with value: %f\\n\", gain); // Update on the AXI-Lite bus XSyfala_Set_gain(dsp, *reinterpret_cast<u32*>(&gain)); return 0; } int main() { [...] initialize_osc(dsp); } Building and executing the example Please read the linux-getting-started tutorial in order to learn how to build and use the Embedded Linux. You can then build the example with the following command: syfala examples/cpp/templates/osc-synth-hls.cpp --arm-target examples/cpp/templates/osc-synth-arm.cpp --linux Then you can copy the resulting build onto your Zybo SD card and use the following command to start the example: syfala-load osc-synth-hls","title":"C++ tutorial"},{"location":"tutorials/cpp-tutorial-advanced/#using-syfala-with-c","text":"","title":"Using syfala with C++"},{"location":"tutorials/cpp-tutorial-advanced/#introduction","text":"While Faust is undoubtedly a nice and easy way to create complex and fully-controllable DSP programs on FPGAs, in some cases - where for instance balancing resource usage and latency becomes a critical issue - bypassing Faust and programming directly in C++ can become a more suitable solution.","title":"Introduction"},{"location":"tutorials/cpp-tutorial-advanced/#how-does-it-work","text":"Ordinarily, the easiest way to get started with syfala is to use Faust to generate the C++ code that is going to be fed to the High Level Synthesis ( HLS ) tool and turned into Hardware Description Language (HDL) code. The resulting DSP kernel (or IP : Intellectual Property) is then going to be added to a more global design , which will include the processing system (PS), our custom-made Integrated Interchip Sound ( i\u00b2s ) and various other modules as well. Consequently - and since we're already using HLS - programming the DSP kernel directly in C++ is entirely possible, but remains a more complex solution, and won't offer the same user-friendly features that Faust is able to provide out-of-the-box.","title":"How does it work?"},{"location":"tutorials/cpp-tutorial-advanced/#pros","text":"Better balance control between FPGA resource usage & latency . HLS-friendly/optimized code. HLS libraries, pragmas & tools.","title":"Pros:"},{"location":"tutorials/cpp-tutorial-advanced/#cons","text":"Limited support of C++ features (up to C++14 ). Complex HLS interfaces & documentation. No out-of-the-box GUI/Serial control interface. Data exchange with ARM through AXI-Lite or DDR memory has to be done manually.","title":"Cons:"},{"location":"tutorials/cpp-tutorial-advanced/#code-structure","text":"The following describes how to program a syfala DSP kernel using C++. It is intended for advanced users.","title":"Code structure"},{"location":"tutorials/cpp-tutorial-advanced/#using-pre-made-examples","text":"To get an idea on how to program the DSP kernel in C++, you can refer to the examples/cpp directory in the syfala repository. For this tutorial, we will build a simple stereo gain DSP kernel. The interface that we propose is pretty straightforward, but there a couple of things that still need to be explained in details:","title":"Using pre-made examples"},{"location":"tutorials/cpp-tutorial-advanced/#signal-types","text":"In the global syfala FPGA design, audio signals are conveyed as streams of 24-bits integers, by default . The bit width can be changed using the --sample-width flag in the syfala command line interface, but cannot be changed to single or double precision floating point types. Since audio DSP programs are usually processing float or double -based signals, a few convenience functions and types have been added in the syfala/utilities.hpp header, which can be easily included in your C++ file: #include <syfala/utilities.hpp> This header defines for instance the type sy_ap_int , as the following: // include/syfala/utilities.hpp using sy_ap_int = ap_int<SYFALA_SAMPLE_WIDTH>; // note: the 'ap_int' (arbitrary precision integer) type is defined by Vitis_HLS in $XILINX_ROOT_DIR/Vitis_HLS/2022.2/include/ap_int.h It also defines the following read/write convenience functions between sy_ap_int and float types. These will come in handy when reading and writing from/to the audio input/output ports. // include/syfala/utilities.hpp namespace Syfala::HLS { /** * @brief ioreadf Read sy_ap_int as float * @param input sy_ap_int data input * @return floating-point conversion of input */ float ioreadf(sy_ap_int const& input); /** * @brief iowritef write floating point data to ap_int * top-level function output. * @param f float data input * @param output ap_int interface output. */ void iowritef(float f, sy_ap_int& output); } You should also be able, from this file, to access some useful compile-time data, such as the current sample rate , or sample-width which are defined with the following macros : #define SYFALA_SAMPLE_RATE 48000 #define SYFALA_SAMPLE_WIDTH 24","title":"Signal types"},{"location":"tutorials/cpp-tutorial-advanced/#audio-inputs-outputs","text":"First, in order to generate the block design that is going to be synthesized by Vivado and make the proper connections with i\u00b2s , syfala needs to be explicitly informed of the number of audio input/output channels that the DSP program is going to have. In our case, for the stereo gain example, we want 2 inputs and 2 outputs . To do so, in the current version of syfala , the following C macros need to be defined somewhere in the code: // examples/cpp/templates/gain.cpp #define INPUTS 2 #define OUTPUTS 2 It will inform the toolchain to use the following audio input and output ports , which will be formatted like this in our final design: audio_in_# (in our case, audio_in_0 and audio_in_1 ) audio_out_# (in our case, audio_out_0 and audio_out_1 )","title":"Audio inputs &amp; outputs"},{"location":"tutorials/cpp-tutorial-advanced/#top-level-interface","text":"The top-level function is the DSP kernel 's' entrypoint, which, in the final block design , will be connected to other peripherals, such as the i\u00b2s and the processing system , with the help of various bus interfaces (AXI, AXI-Lite). Its arguments should be considered as a list of input & output ports , with: pointer arguments being output arguments (or both input & output arguments) non-pointer arguments being input arguments only. array arguments can be both. It's signature should always be void syfala(...) : // examples/cpp/templates/gain.cpp /* Top-level interface function */ void syfala ( // Audio input/output ports (variable): sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], // The following arguments are required and should not be changed: int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ) { [...] Again, each audio input & output arguments have to be formatted exactly like the following: void syfala ( // Audio input/output ports (variable): sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], And have to be followed by these exact same arguments (which we will present in the next sections): // The following arguments are required and their respective names should not be changed: int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ) { [...] Below, the HLS interface pragmas should also remain the same, they're here to indicate to Vitis HLS two things: to split the input/output audio arguments into individual ports (which will be named audio_in_0 , audio_in_1 , audio_out_0 , audio_out_1 ) to map some of the top-level arguments to AXI and AXI-Lite bus interfaces (which will be further explained later). #pragma HLS array_partition variable=audio_in type=complete #pragma HLS array_partition variable=audio_out type=complete #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram","title":"Top-level interface"},{"location":"tutorials/cpp-tutorial-advanced/#initialization","text":"","title":"Initialization"},{"location":"tutorials/cpp-tutorial-advanced/#waiting-for-arm-initialization","text":"Since the DSP kernel and the ARM are not synchronized at a sample-rate level , and the ARM has to first initialize a few peripherals (audio codecs, GPIOs, UART...) before being able to do anything else, it is necessary for the DSP kernel to wait for the arm_ok signal to be received before doing any initialization or processing. Once the ARM is ready, the initialization routine can be done manually with, for example, a static initialization variable. In our stereo gain example, we do: static bool initialization = true; [...] /* Initialization and computations can start after the ARM * has been initialized */ if (arm_ok) { /* First function call: initialization */ if (initialization) { // Initialize all runtime data here. // don't forget to toggle the variable off initialization = false; } else {","title":"Waiting for ARM initialization"},{"location":"tutorials/cpp-tutorial-advanced/#bypassmute-switches","text":"In all standard syfala designs , the bypass and mute ports of a DSP kernel are pre-mapped to SW0 and SW1 in Zybo Z10/Z20 boards. You can choose to acknowledge and process them if you want: } else { /* Every other iterations: * either process the bypass & mute switches... */ if (bypass) { audio_out[0] = audio_in[0]; audio_out[1] = audio_in[1]; } else if (mute) { audio_out[0] = 0; audio_out[1] = 0; } else {","title":"Bypass/mute switches"},{"location":"tutorials/cpp-tutorial-advanced/#dsp-code","text":"Finally, here is an example of a processing function taking advantage of the Syfala::HLS::ioreadf() and Syfala::HLS::iowritef() convenience functions in order to switch back & forth between float and sy_ap_int types. } else { /* ... or compute samples here */ compute(audio_in, audio_out); } For our stereo gain example, we first convert the input data to float , multiply it by 0.5f and write it back to the output ports . static void compute(sy_ap_int const inputs[], sy_ap_int outputs[]) { // if you need to convert to float, use the following: // (audio inputs and outputs are 24-bit integers by default) float f0 = Syfala::HLS::ioreadf(inputs[0]) * 0.5f; float f1 = Syfala::HLS::ioreadf(inputs[1]) * 0.5f; Syfala::HLS::iowritef(f0, outputs[0]); Syfala::HLS::iowritef(f1, outputs[1]); }","title":"DSP code"},{"location":"tutorials/cpp-tutorial-advanced/#building-and-flashing-with-the-syfala-cli","text":"syfala works the same way with C++ targets, you'll only need to replace the Faust .dsp target with your .cpp file in the command line. We can now try to synthesize our stereo gain DSP kernel , in order to see if our code compiles: syfala examples/cpp/templates/gain.cpp --board Z20 --hls Once the high-level synthesis is done, syfala should display the Vitis HLS estimate of the kernel's latency and resource utilization : DSP 2% (6) FF ~0% (997) LUT 3% (2070) BRAM 0% (0) Latency: Tot. 47 Cycles 0.382us","title":"Building and flashing with the syfala CLI"},{"location":"tutorials/cpp-tutorial-advanced/#verifying-code-with-c-simulation-csim","text":"We know now that our code compiles, but we won't be able to test it until the full Vivado synthesis & implementation are done, which, depending on your machine, can take up some time. We'll then have to flash the device, connect an audio-input and a headset to the board, and see if the stereo gain in our example is properly applied. Needless to say, the process is a bit long and tedious. You don't really want to go through all of that too many times when you're debugging code, and that's precisely where C simulation ( CSIM ) comes into play. C simulation is an important Vitis HLS feature, which allows you to test your C-written kernel without having to get through the full synthesis process. In short: Vitis HLS guarantees (with a few exceptions) that the outputs of your kernel is going to be the same as they would be in a real context of execution.","title":"Verifying code with C simulation (CSIM)"},{"location":"tutorials/cpp-tutorial-advanced/#using-pre-defined-generic-templates","text":"Now, if we get back to our stereo gain example, and since it is a really simple one, we will take advantage of the generic CSIM C++ template that is available in the syfala source tree (located in tests/csim/csim_cpp_template.cpp ). Here's an example of command that can be used: syfala examples/cpp/templates/gain.cpp --csim tests/csim/csim_cpp_template.cpp --csim-inputs tests/stimuli --csim-iter 64 # output results will be stored in reports/csim/gain/out0.txt & reports/csim/gain/out1.txt Where: --csim tests/csim/csim_cpp_template.cpp - the simulation test file. --csim-inputs tests/stimuli - we specify using the tests/stimuli directory to fetch input samples. tests/stimuli contains two .txt files, named in0.txt and in1.txt and are filled with normalized ( -1.f to 1.f ) floating point values. --csim-iter 64 - the DSP kernel will be called 64 times (64 samples). We can finally verify the outputs of our stereo gain kernel, by comparing the input stimuli files with the output files (output samples should be input/2 ).","title":"Using pre-defined generic templates:"},{"location":"tutorials/cpp-tutorial-advanced/#writing-your-own-csim","text":"While the generic template will work for simple DSP kernels that have the same top-level function signature, you will have to write your own CSIM file to validate kernels that have more complex interfaces. In order to do this, and since the generic template is scripted and a bit complicated to read, let's take inspiration from the csim_cpp_template_gain.cpp example file, and see what it is actually doing: We first declare the syfala top-level function prototype , which is going to have the exact same signature as in our gain.cpp file. // tests/csim/csim_cpp_template_gain.cpp void syfala ( sy_ap_int audio_in[2], sy_ap_int audio_out[2], int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug ); We then instantiate and pre-initialize the values that are going to be passed to the syfala function arguments : sy_ap_int audio_in[2] = {0, 0}; sy_ap_int audio_out[2] = {0, 0}; // Here, we simulate having the ARM initialized and ready, by setting the 'arm_ok' variable to 'true': int arm_ok = true; // The i2s is not part of the simulation, so this really doesn't matter: bool i2s_rst = false; // We don't use DDR memory, nor the bypass/mute switches: set everything to zero: float* mem_zone_f = nullptr; int* mem_zone_i = nullptr; bool bypass = false; bool mute = false; bool debug = false; We also instantiate float type copies of inputs and outputs, for setting random input values, and printing outputs. float f_inputs[2] = {0, 0}; float f_outputs[2] = {0, 0}; Then, call the syfala function with all the proper arguments. // For each simulation iteration (set with the '--csim-iter' flag) for (int i = 0; i < SYFALA_CSIM_NUM_ITER; i++) { if (i > 0) { // first iteration = initialization, inputs will be ignored // wait for second iteration. f_inputs[0] = (float)rand()/RAND_MAX; f_inputs[1] = (float)rand()/RAND_MAX; } Syfala::HLS::iowritef(f_inputs[0], audio_in[0]); Syfala::HLS::iowritef(f_inputs[1], audio_in[1]); // call top-level function syfala(audio_in, audio_out, arm_ok, &i2s_rst, mem_zone_f, mem_zone_i, bypass, mute, debug ); [...] } Once it is done, fetch and print the input/output samples (as float) : [...] f_outputs[0] = Syfala::HLS::ioreadf(audio_out[0]); f_outputs[1] = Syfala::HLS::ioreadf(audio_out[1]); printf(\"[ch0] input: %f, result: %f\\n\", f_inputs[0], f_outputs[0]); printf(\"[ch1] input: %f, result: %f\\n\", f_inputs[1], f_outputs[1]); }","title":"Writing your own CSIM"},{"location":"tutorials/cpp-tutorial-advanced/#optimizing-code","text":"For simple examples, such as our previous stereo-gain kernel , there's obviously not going to be an immediate and imperative need for optimization. Consequently, we will this time get our hands on something a little more resource and computation hungry . In audio digital signal processing, FIR filters are encountered on a very regular basis, and, depending on the number of coefficients that they have, they can be tricky to implement on FPGAs, especially if no optimizations are made. Let's have a look at our examples/cpp/fir/fir.cpp example: #include \"coeffs.hpp\" static float coeffs[] = { 0.000000000000000000, -0.000000914435621961, 0.000000000000000000, 0.000008609100789076, [...] }; #define INPUTS 0 #define OUTPUTS 2 #define NCOEFFS 115 static float samples[NCOEFFS]; static float sawtooth; float compute_fir() { float out = 0; samples[0] = sawtooth; for (int n = 0; n < NCOEFFS; ++n) { out += mem[n] * coeffs115[n]; } for (int j0 = NCOEFFS-1; j0 > 0; --j0) { mem[j0] = samples[j0-1]; } sawtooth += 0.01f; sawtooth = fmodf(sawtooth, 1.f); return out; } In this example, we first statically define a bunch of FIR coefficients in the examples/cpp/fir/coeffs.hpp header, as well as a zero-initialized array ( samples[NCOEFFS] ), which will be used to store the previous samples. The compute_fir function generates a really basic phasor/sawtooth signal , and feed it into the FIR filter. Once all the samples are computed for NCOEFFS , we shift the samples[] array by one in the right direction. Then, as in our previous examples, we call the ' compute ' function from the syfala top-level function. In this case, we are going to write the same signal on both left and right output channels. /* ... or compute samples here * if you need to convert to float, use the following: * (audio inputs and outputs are 24-bit integers) */ float f = compute_fir(); Syfala::HLS::iowritef(f, audio_out[0]); Syfala::HLS::iowritef(f, audio_out[1]);","title":"Optimizing code"},{"location":"tutorials/cpp-tutorial-advanced/#monitoring-latency-resource-utilization","text":"Now, in order to evaluate the program's performance and efficiency, the first thing that we can do is run the High Level Synthesis step and carefully read the output results . This can be done using the following command: syfala examples/cpp/fir/fir.cpp --board Z10 --hls which is going to give us this estimate : fir.cpp Z10 48000 24 (Vitis HLS estimate) 115 coefficients - DSP: 8% (7) - Reg: 5% (1829) - LUT: 20% (3617) - BRAM: 2% (3) Tot. 1057 Cycles, 8.602us Max. 2559 Cycles, 20,8333us Lat. 41% Needless to say, even for a Zybo Z7-10 , this is not really satisfying: if we project ourselves linearly , it means that we could probably only fit at best a 300 coefficients FIR filter or so without reaching the maximum sample latency . Let's try it out with 300 coefficients now: fir.cpp Z10 48000 24 (Vitis HLS estimate) 300 coefficients - DSP: 8% (7) - Reg: 5% (1837) - LUT: 20% (3619) - BRAM: 2% (4) Tot. 2722 Cycles, 22.152us Max. 2559 Cycles, 20,8333us Lat. 106% With a 300-coefficients filter , we even actually go a little bit above max latency . On the other hand, we can see that the resources stay pretty much the same as before, so there's probably room for improvement here in terms of balance between latency & resource utilization, and the first thing we can do to remedy this problem would maybe be to use some of the Vitis HLS C/C++ pragmas .","title":"Monitoring latency &amp; resource utilization"},{"location":"tutorials/cpp-tutorial-advanced/#using-optimization-directives-pragmas","text":"Now, what we really want Vitis HLS to do here, for the latency to drop down, would be to parallelize the computations a bit more. If we go through Vitis HLS documentation , there are a couple of things that can be tried in order to do that, without modifying the code too much. Our first choice here would be to use the unroll #pragma , which could introduce more parallelization in our accumulation loop : float compute_fir() { float out = 0; mem[0] = sawtooth; for (int n = 0; n < NCOEFFS; ++n) { #pragma HLS UNROLL out += mem[n] * coeffs[n]; } [...] If we try to run HLS with this code, we see that pretty much nothing happens (the results may even be worse than before). That's because this particular accumulation loop cannot really be parallelized without using what we call a balanced tree (in our case, an 'adder tree'). By default, Vitis HLS does not automatically make this optimization for floating-point operations, but it can be enabled using the --unsafe-math-optimizations (or --umo ) flag in the syfala command line: syfala examples/cpp/fir/fir300.cpp --hls --umo Let's now try to see what it's giving us for our 300 coefficients example: fir.cpp Z10 48000 (Vitis HLS estimate) 300 coefficients - DSP: 31% (25) - Reg: 18% (6532) - LUT: 66% (3619) - BRAM: 1% (2) Tot. 529 Cycles, 4.536us Max. 2559 Cycles, 20,8333us Lat. 20% The results are definitely more reasonable in terms of latency. On the other hand, we can see that the resources ( LUTs in particular) have increased a lot. If we push it a little bit more, let's say with 600 coefficients this time, this is what we get: fir.cpp Z10 48000 (Vitis HLS estimate) 600 coefficients - DSP: 31% (25) - Reg: 23% (8101) - LUT: 85% (15019) - BRAM: 1% (2) Tot. 987 Cycles, 8.537us Max. 2559 Cycles, 20,8333us Lat. 38% With 600 coefficients , we're still okay on latency, but the Lookup Table ( LUT ) number is now getting dangerously high . Remember: the numbers shown on these reports are only an estimate , which means that this number could be in reality a bit higher, introducing the risk that our kernel might not actually fit on the Zybo Z7-10 board.","title":"Using optimization directives &amp; pragmas"},{"location":"tutorials/cpp-tutorial-advanced/#accurate-reports","text":"In a situation like this one, it is usually a good idea to tell Vitis HLS that we need a more accurate report on the allocated resources. Adding the --accurate-use flag to the syfala command line will do exactly that for us: syfala examples/cpp/fir300.cpp --hls --umo --accurate-use This will tell Vitis HLS to run both the synthesis and implementation steps on the DSP kernel only (not on the final design). It usually takes more time (approximately 5 to 10 minutes, depending on the kernel), but it will give precise and valuable information on the resources that will be used on the board: GUIDELINE - DSP: 31% (25) OK (80%) - Reg: 22% (7912) OK (50%) - LUT: 70% (12332) WARNING (70%) - BRAM: 1% (2) OK (80%) If we now look at the GUIDELINE column, we can see that we have indeed a WARNING on the LUT section, which basically means that the design may not fit on the board. But instead of trying to run the full synthesis and hope for the best, maybe we can tweak the pragmas a little more, to give ourselves a safer margin. Vitis HLS documentation tells us that we can add to the UNROLL pragma ** a parameter called factor , which basically represents the level of parallelization that we want to introduce in the loop. When this parameter is not explicitly set , Vitis HLS will fully unroll the loop , which might explain why the number of LUTs has sky-rocketted in our previous examples. If we tune this factor with a lower number, it might help bring down the utilization of this specific FPGA resource. Let's try it now with a factor** 10 , and see what it does: float compute_fir() { [...] for (int n = 0; n < NCOEFFS; ++n) { #pragma HLS UNROLL factor=10 out += samples[n] * coeffs[n]; } [...] Which is going to give us: fir.cpp Z10 48000 (Vitis HLS estimate) 600 coefficients - DSP: 15% (12) - Reg: 9% (3452) - LUT: 28% (4966) - BRAM: 3% (4) Tot. 1139 Cycles, 9.269us Max. 2559 Cycles, 20,8333us Lat. 44% This is starting to get a lot better, and if we go up to 1000 coefficients now: fir.cpp Z10 48000 (Vitis HLS estimate) 1000 coefficients - DSP: 15% (12) - Reg: 9% (3452) - LUT: 28% (4966) - BRAM: 3% (4) Tot. 1859 Cycles, 15.129us Max. 2559 Cycles, 20,8333us Lat. 72% The results here are getting really interesting, since we can clearly see that the resources used are exactly the same as our 600 coefficients example. Latency is the only thing that has increased, from 44% to 72%, which remains a somewhat comfortable margin.","title":"Accurate reports"},{"location":"tutorials/cpp-tutorial-advanced/#using-a-sample-block-configuration-multisample","text":"Another method that can be used in order to balance latency and resource utilization would be for the DSP kernel to process a block of samples instead of a single one, i.e. to ' bufferize ' the signal to maximize efficiency and parallelization. Not unlike CPUs, this may also result in better FPGA resource dispatch and/or throughput, but has on the other hand the drawback of introducing I/O latency . Syfala supports sample block processing for both Faust and C++ targets, by adding the --multisample <N> flag: syfala examples/cpp/templates/gain-multisample.cpp --multisample 16 --hls For C++ targets, the code needs to be adapted a bit, since we now have FIFO arrays as inputs and outputs, we have to declare them as C multidimensional arrays , like the following: void syfala ( sy_ap_int audio_in[INPUTS][SYFALA_BLOCK_NSAMPLES], sy_ap_int audio_out[OUTPUTS][SYFALA_BLOCK_NSAMPLES], [...] #pragma HLS INTERFACE ap_fifo port=audio_in #pragma HLS INTERFACE ap_fifo port=audio_out #pragma HLS array_partition variable=audio_in type=complete #pragma HLS array_partition variable=audio_out type=complete #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram Within the top-level function, this also changes the way we have to process the bypass/mute switches : } else { /* Every other iterations: * either process the bypass & mute switches... */ if (bypass) { for (int n = 0; n < OUTPUTS; ++n) { for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { audio_out[n][m] = audio_in[n][m]; } } } else if (mute) { for (int n = 0; n < OUTPUTS; ++n) { for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { audio_out[n][m] = 0; } } And finally our compute function : } else { /* ... or compute samples here */ compute(audio_in, audio_out); } // examples/cpp/templates/gain-multisample.cpp static void compute( sy_ap_int const inputs[INPUTS][SYFALA_BLOCK_NSAMPLES], sy_ap_int outputs[OUTPUTS][SYFALA_BLOCK_NSAMPLES] ) { for (int n = 0; n < OUTPUTS; ++n) for (int m = 0; m < SYFALA_BLOCK_NSAMPLES; ++m) { // if you need to convert to float, use the following: // (audio inputs and outputs are 24-bit integers by default) float f = Syfala::HLS::ioreadf(inputs[n][m]) * 0.5f; Syfala::HLS::iowritef(f, outputs[n][m]); } } }","title":"Using a 'sample block' configuration (--multisample)"},{"location":"tutorials/cpp-tutorial-advanced/#fir-example","text":"Let's get back to our FIR example, in order to see what can be done to optimize things a bit more. An unoptimized multisample example can be found in examples/cpp/fir/fir-multisample.cpp . Let's see what kind of results we get with a block of size 16 and 300 coefficients : syfala examples/cpp/fir/fir-multisample.cpp --board Z10 --multisample 16 --hls fir-multisample.cpp Z10 48000 (Vitis HLS estimate) block size: 16 samples 300 coefficients - DSP: 8% (7) - Reg: 5% (1935) - LUT: 21% (3829) - BRAM: 3% (4) Tot. 43585 Cycles, 0.355ms Per sample: 2724 Cycles. Max. 2559 Cycles, 20,8333us Lat. 106% Compared to our unoptimized 'one-sample' FIR example with the same number of coefficients , and considering we also introduce an I/O latency of 16 samples (about 0.3 milliseconds), we can say with confidence that this is not really good, and that's essentially because - if we carefully look at the more advanced reports that Vitis HLS is giving us - the samples are still processed sequentially , which is not going to introduce a lot of changes compared to the single-sample version. Consequently, even if we unroll our accumulation loop as we did before, the results are also going to be more or less the same. [...]","title":"FIR example"},{"location":"tutorials/cpp-tutorial-advanced/#csim-with-multisample-configuration","text":"syfala examples/cpp/templates/gain-multisample.cpp --multisample 32 --csim tests/csim/csim_cpp_template_multisample.cpp --csim-inputs tests/stimuli --csim-iter 5 # output results will be stored in reports/csim/gain-multisample/out0.txt & reports/csim/gain-multisample/out1.txt","title":"CSIM with --multisample configuration:"},{"location":"tutorials/cpp-tutorial-advanced/#sharing-processingcontrol-with-the-arm-executable","text":"Since the resources on a FPGA are far from being infinite, it is usually preferable to use a custom ARM executable for some specific use-cases, such as: Initialization of constants , wavetables ... Long delay-lines (stored/initialized in DDR memory). Control-rate computations. etc. This is exactly what syfala does under the hood with Faust programs : control-rate expressions, resulting from the sliders/button being interacted with, are for instance made on the ARM, and shared through a memory bus called AXI-Lite . The following example shows how we can implement a similar (though simpler) control-rate gain parameter, which we will be able update on the console and share with the DSP kernel.","title":"Sharing processing/control with the ARM executable"},{"location":"tutorials/cpp-tutorial-advanced/#basic-axi-lite-control-example","text":"This example, which you can find in examples/cpp/templates/gain-control-hls.cpp , is almost exactly the same as our previous gain.cpp example. The only difference is that we want to make variable the gain parameter that we hardcoded to 0.5f before. All we basically need to do here is to introduce a new floating-point argument gain in the top-level function , which will also be declared as an AXI-Lite interface port using the appropriate pragma : void syfala ( sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], [...] float gain ) { [...] #pragma HLS INTERFACE s_axilite port=gain For the rest of the code, we simply add gain to the compute() function's arguments, and then apply it to the inputs. } else { /* ... or compute samples here */ compute(audio_in, audio_out, gain); } static void compute(sy_ap_int const inputs[], sy_ap_int outputs[] float gain) { float f0 = Syfala::HLS::ioreadf(inputs[0]) * gain; float f1 = Syfala::HLS::ioreadf(inputs[1]) * gain; Syfala::HLS::iowritef(f0, outputs[0]); Syfala::HLS::iowritef(f1, outputs[1]); } That's it! On the HLS side of things, it remains pretty simple. On the ARM side , it gets unfortunately a bit more complicated, as we are going to see now :-)","title":"Basic AXI-Lite control example"},{"location":"tutorials/cpp-tutorial-advanced/#dsp-kernel-drivers","text":"We already know that Vitis HLS is going to take our gain-control-hls.cpp file and generate the VHDL-equivalent, which is then going to be integrated in our final design. But it's not the only thing that it does: among other things, it also generates 'drivers' for interacting with the kernel from the ARM . Let's first synthesize our DSP kernel with Vitis HLS, and take a look at some of the files that are generated in the build directory: syfala examples/cpp/templates/gain-control-hls.cpp --hls If we now go in the build/syfala_ip/syfala/impl/ip/drivers/syfala_v1_0/src directory, we see that a Makefile and some C files have been generated , specifically: - xsyfala.c - xsyfala.h - xsyfala_hw.h - xsyfala_linux.c - xsyfala_sinit.c We're not going to go into details about each file: the one that is truly interesting to us in the context of our example is the xsyfala.h C header . If we open this file , we see that the following function prototypes are declared: void XSyfala_Set_arm_ok(XSyfala *InstancePtr, u32 Data); u32 XSyfala_Get_arm_ok(XSyfala *InstancePtr); void XSyfala_Set_mem_zone_f(XSyfala *InstancePtr, u64 Data); u64 XSyfala_Get_mem_zone_f(XSyfala *InstancePtr); void XSyfala_Set_mem_zone_i(XSyfala *InstancePtr, u64 Data); u64 XSyfala_Get_mem_zone_i(XSyfala *InstancePtr); void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data); u32 XSyfala_Get_gain(XSyfala *InstancePtr); You can see that these functions' names match some of the arguments that we put in the top-level function. That's because these arguments are already registered as AXI or AXI-Lite interface arguments in our DSP kernel code : void syfala ( [...] int arm_ok, float* mem_zone_f, int* mem_zone_i, float gain ) { #pragma HLS INTERFACE s_axilite port=arm_ok #pragma HLS INTERFACE s_axilite port=gain #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram In our case, since the other arguments arm_ok , mem_zone_f and mem_one_i are already taken of by syfala , the one that is going to be useful to us is the gain parameter, and, specifically, its 'setter' function : void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data)","title":"DSP kernel drivers"},{"location":"tutorials/cpp-tutorial-advanced/#writing-the-arm-executable","text":"In order to code the executable that is going to run on the ARM, we will take the code from source/arm/baremetal/arm_minimal.cpp , which contains all that is necessary for the application to run properly, and we are going to add our gain control function . The result can be seen in examples/cpp/templates/gain-control-arm.cpp . In our update_gain() function, we are simply going to fetch a new gain value using scanf , and update it on the FPGA using the XSyfala_Set_gain driver function : static void update_gain(XSyfala& syfala) { static float gain = 1.f; printf(\"Enter gain value (from 0.f to 1.f)\\r\\n\"); scanf(\"%f\", &gain); printf(\"Gain: %f\\r\\n\", gain); XSyfala_Set_gain(&syfala, *reinterpret_cast<u32*>(&gain)); } Note : floating-point data have to be set using reinterpret_cast<u32*> , otherwise, it will be interpreted as an integer and truncated. In the main() function, all we have to do now is call our update_gain() function in the main event loop , passing it the XSyfala handle struct . int main(int argc, char* argv[]) { XSyfala syfala; UART::data uart; // UART & GPIO should be initialized first, // i.e. before outputing any information on leds & stdout. GPIO::initialize(); UART::initialize(uart); // Wait for all peripherals to be initialized Status::waiting(RN(\"[status] Initializing peripherals & modules\")); Audio::initialize(); IP::initialize(syfala); IP::set_arm_ok(&syfala, true); Status::ok(RN(\"[status] Application ready, now running...\")); // main event loop: while (true) { // -------------------------------------------------------- update_gain(syfala); sleep(1); // -------------------------------------------------------- } return 0; }","title":"Writing the ARM executable"},{"location":"tutorials/cpp-tutorial-advanced/#running-syfala","text":"Finally, to fully run syfala on our example , including the ARM executable, we need to add the --arm-target flag to the command line, with the path to our .cpp file as an argument: syfala examples/cpp/templates/gain-control-hls.cpp --arm-target examples/cpp/templates/gain-control-arm.cpp --board Z10","title":"Running syfala"},{"location":"tutorials/cpp-tutorial-advanced/#axi-lite-array-arguments","text":"It is also entirely possible to pass array arguments to the AXI-Lite bus. On the HLS side, it remains straightforward: void syfala ( sy_ap_int audio_in[INPUTS], sy_ap_int audio_out[OUTPUTS], [...] float my_control_parameters[64] ) { #pragma HLS INTERFACE s_axilite port=my_control_parameters In the xsyfala.h header, the matching functions generated by Vitis HLS will be the following: u32 XSyfala_Write_my_control_parameters_Words(XSyfala *InstancePtr, int offset, word_type* data, int length); u32 XSyfala_Read_my_control_parameters_Words(XSyfala *InstancePtr, int offset, word_type* data, int length); Which you'll be able to access like in the following example: XSyfala dsp; // Instantiate and initialize a local array float my_control_parameters[64]; for (int n = 0; n < 64; ++n) { my_control_parameters[n] = n; } // Write all of the local array's data to the AXI-Lite bus // using the appropriate function: XSyfala_Write_my_control_parameters_Words ( &dsp, 0, reinterpret_cast<u32*>(my_control_parameters), 64 );","title":"AXI-Lite array arguments"},{"location":"tutorials/cpp-tutorial-advanced/#ddr-axi-axi-lite-control-embedded-linux-and-osc","text":"Let's take a different example this time, and since we haven't really dealt with audio synthesis yet, we will implement a simple wavetable-based sine oscillator , for which its frequency and gain parameter will be remotely controllable with the Open Sound Control protocol, and its wavetable allocated on the DDR ram, initialized on the ARM , and, finally, read from the DSP kernel . You can find the HLS implementation in examples/cpp/templates/osc-synth-hls.cpp and the ARM (Linux) part in examples/cpp/templates/osc-synth-arm.cpp . // examples/cpp/templates/osc-synth-hls.cpp #define INPUTS 0 #define OUTPUTS 2 void syfala ( sy_ap_int audio_out[OUTPUTS], int arm_ok, bool* i2s_rst, float* mem_zone_f, int* mem_zone_i, bool bypass, bool mute, bool debug, float frequency, float gain ) { #pragma HLS INTERFACE s_axilite port=frequency #pragma HLS INTERFACE s_axilite port=gain #pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram #pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram Our DSP kernel HLS code , above and below, is still pretty straightforward here: We add two read-only floating-point parameters frequency and gain to the top-level function arguments, Just like our previous example, we register them to the AXI-Lite bus with the proper pragmas . Then, we're simply going to update and compute the oscillator's phase , and read its wavetable using the mem_zone_f pointer read/write argument. As you may have noticed, this specific argument is registered on the m_axi ( AXI ) bus with a different HLS pragma . } else { /* ... or compute samples here */ static float phase; static int iphase; // Update increment value and the oscillator's phase float incr = frequency/SYFALA_SAMPLE_RATE; iphase = (int)(phase * 16384); phase = fmodf(phase + incr, 1.f); // Read the DDR wavetable at index [iphase] float f = mem_zone_f[iphase]; #ifdef __CSIM__ printf(\"iphase: %d, f: %f\\n\", iphase, f); #endif // Finally, apply gain factor f *= gain; Syfala::HLS::iowritef(f, audio_out[0]); Syfala::HLS::iowritef(f, audio_out[1]); } Note : we fundamentally 'assume' the mem_zone_f variable is directly pointing to the wavetable's start, which we are going to really make sure of in the code that is going to be on the Linux/ARM-side of things.","title":"DDR AXI + AXI-Lite control (Embedded Linux and OSC)"},{"location":"tutorials/cpp-tutorial-advanced/#allocatinginitializing-the-wavetable","text":"In the ARM code, we will first retrieve a RAM pointer by calling the Syfala::Memory::initialize() API function, which will give us a pointer to the base of a free portion of DDR memory , which has been pre-reserved when building the Embedded Linux for Syfala. It will also automatically write the address to the AXI bus and the mem_zone_f function argument that we have in our HLS code. Since we only have one wavetable , hence a single memory zone, we can leave things as is (without any offset) and just consider mem.f_zone as the start of our wavetable . Then, we can safely initialize the wavetable . Here, we write a single period of a very basic sinewave . // examples/cpp/templates/osc-synth-arm.cpp #define WAVETABLE_LEN 16384 static float frequency = 440.f, gain = 0.25f; static void initialize_default_values(XSyfala& dsp) { // Initialize AXI-Lite based controls, // the same way that we did in our previous example. XSyfala_Set_frequency(&dsp, *reinterpret_cast<u32*>(&frequency)); XSyfala_Set_gain(&dsp, *reinterpret_cast<u32*>(&gain)); } static void initialize_wavetables(float* mem, int len) { // Write a single period of a sinewave for (int n = 0; n < len; ++n) { mem[n] = std::sin((float)(n)/len * M_PI * 2); } } int main(int argc, char* argv[]) { [...] // The following function will set 'mem.f_zone' pointer // to the base of a free portion of DDR memory Memory::initialize(dsp, mem, 0, WAVETABLE_LEN); // We also initialize 'frequency' and 'gain' parameters to their default value initialize_default_values(dsp); // and finally, initialize the wavetable. initialize_wavetables(mem.f_zone, WAVETABLE_LEN); [...] }","title":"Allocating/initializing the wavetable"},{"location":"tutorials/cpp-tutorial-advanced/#osc-control-example","text":"Since we're using the Embedded Linux in this example, we will take advantage of using the liblo Open Sound Control library , which is installed by default on our Alpine Linux distribution . // examples/cpp/templates/osc-synth-arm.cpp /** * Start a new OSC server thread on port '8888', * register both '/osc/frequency' and '/osc/gain' float parameters * assign them the proper callback functions. */ static void initialize_osc(XSyfala& dsp) { osc = lo_server_thread_new(\"8888\", error_hdl); lo_server_thread_add_method(osc, \"/osc/frequency\", \"f\", osc_frequency_hdl, &dsp); lo_server_thread_add_method(osc, \"/osc/gain\", \"f\", osc_gain_hdl, &dsp); lo_server_thread_start(osc); } static int osc_frequency_hdl ( const char* path, const char* types, lo_arg** argv, int argc, lo_message data, void* udata ){ XSyfala* dsp = static_cast<XSyfala*>(udata); frequency = argv[0]->f; printf(\"[OSC] Updating /osc/frequency with value: %f\\n\", frequency); // Update on the AXI-Lite bus XSyfala_Set_frequency(dsp, *reinterpret_cast<u32*>(&frequency)); return 0; } static int osc_gain_hdl ( const char* path, const char* types, lo_arg** argv, int argc, lo_message data, void* udata ){ XSyfala* dsp = static_cast<XSyfala*>(udata); gain = argv[0]->f; printf(\"[OSC] Updating /osc/gain with value: %f\\n\", gain); // Update on the AXI-Lite bus XSyfala_Set_gain(dsp, *reinterpret_cast<u32*>(&gain)); return 0; } int main() { [...] initialize_osc(dsp); }","title":"OSC control example"},{"location":"tutorials/cpp-tutorial-advanced/#building-and-executing-the-example","text":"Please read the linux-getting-started tutorial in order to learn how to build and use the Embedded Linux. You can then build the example with the following command: syfala examples/cpp/templates/osc-synth-hls.cpp --arm-target examples/cpp/templates/osc-synth-arm.cpp --linux Then you can copy the resulting build onto your Zybo SD card and use the following command to start the example: syfala-load osc-synth-hls","title":"Building and executing the example"},{"location":"tutorials/cpp-tutorial-advanced/#_1","text":"","title":""},{"location":"tutorials/embedded-linux-getting-started/","text":"syfala-linux getting started Requirements Xilinx toolchain version > 2022.2 An available SD card The following Linux packages installed on your machine: gcc-arm-none-eabi gnutls-dev bison flex libssl-dev bc u-boot-tools cpio libyaml-dev curl kmod squashfs-tools qemu-user-static Building Available commands From scratch First , a regular syfala project has to be built with the following options: syfala examples/virtualAnalog.dsp --linux The --linux option is used for compiling the host-side ( ARM ) application with the linux-specific source files (otherwise, it would be compiling the standard baremetal one). After synthesis , the script will detect that you don't currently have a linux build, which is required for building the application, and will download and build everything for you, you'll just have to flash it to your formatted SD card afterwards Outputs The build outputs are located in the build-linux/output directory, with two distinct boot and root subdirectories, which then will have to be be flashed on the first and second partitions of your SD card. Usage Formatting the SD card The SD card has to be formatted like so: 1st partition: FAT32 2nd partition: ext4 (Linux filesystem) There are many ways to achieve this, for instance: # you can just replace </dev/...> with your SD device, e.g: /dev/sda or /dev/mmcblk0 sudo parted /dev/... --script -- mklabel msdos sudo parted /dev/... --script -- mkpart primary fat32 1MiB 128MiB sudo parted /dev/... --script -- mkpart primary ext4 128MiB 100% sudo parted /dev/... --script -- set 1 boot on sudo parted /dev/... --script -- set 1 lba on sudo mkfs.vfat /dev/device-partition-1 # e.g. /dev/sda1 sudo mkfs.ext4 /dev/device-partition-2 # e.g. /dev/sda2 sudo parted /dev/... --script print Flashing boot & root partitions # In case your SD device is /dev/sda # 1. Copying boot partition files sudo mount /dev/sda1 /mnt sudo cp -r build-linux/output/boot/* /mnt sync sudo umount /mnt # 2. Copying root partition contents sudo mount /dev/sda2 /mnt sudo cp -r ~/Repositories/syfala/dev/main/build-linux/root/alpine-3.19.1/alpine-root/* . # This might take a while... sync sudo umount /mnt Booting Once flashed, just insert the SD card in your device's socket, make also sure it is configured to boot on SD (For the Zybo boards, you'll have to place a shorting jumper on SD instead of JTAG / QSPI ). Connecting You can still connect through the ttyUSB Serial Port , or with SSH . for Serial Port connection, check that devices /dev/ttyUSB0 and /dev/ttyUSB1 are present on your host and use a serial communication program with following configuration: device /dev/ttyUSB1 , 115200 8N1 (115200 bits/second, one start bit, eight (8) data bits, no (N) parity bit, and one (1) stop bit), no hardware flow control and no software flow control. If hardware flow control is enable, the serial connection will not behave properly. for instance when using minicom: minicom -b 115200 -D/dev/ttyUSB1 -8 (check hardware flow control in minicom, ctrl-A Z). Linux booting console will appear. A login prompt will appear as soon as the booting process has completed: Welcome to Alpine Linux 3.17 Kernel 6.6.0-xilinx on an armv7l (/dev/ttyPS0) syfala login: for SSH connection, make sure that you are connected on the same network as your device's, get its IP address by serial connection as explained above and log as root: ssh root@192.168.0.1 . Login/users The rootfs has the same structure as any Linux build. All DSP builds are located in the /root/ directory The password required to login as root is syfala Faust DSP builds All the DSP builds made with the syfala toolchain are placed in the /root directory by default. For instance, if you make a build from the virtualAnalog.dsp file , the bitstream / application outputs will be located in: /root/virtualAnalog/bitstream.bin /root/virtualAnalog/application.elf You can then use the syfala-load <target> [--list | --help] utility command (e.g. syfala-load virtualAnalog ), which will take care of loading the bitstream and executing the app properly. You can also do all of that manually of course: first, load the bitstream by entering the following command line: fpgautil -b /root/virtualAnalog/bitstream.bin and then execute the Host application like you would normally do with a Linux binary: cd /root/virtualAnalog ./application.elf If you wish to add another build to the SD card, you just have to re-run the syfala toolchain normally on your computer, with the --linux option. Your previous builds won't be erased or modified. syfala examples/fm.dsp --linux Once the build is complete, you will have two distinct project directories in your build-linux/root/alpine-3.19.1/alpine-root/ directory: root/virtualAnalog root/fm You will then have to re-flash your SD card to update the root partition , or directly copy the directory through ssh (e.g. with the scp command). Getting the device's IP & port from avahi (for network-based control) Once a DSP target is loaded with the syfala-load command, an avahi service is automatically started in a separate thread. If your desktop machine is on the same network as the FPGA board, and you have avahi installed & running, you should be able to retrieve the FPGA board's IP address and port required for the HTTP/OSC controls. You can use the avahi-browse command in order to do so: avahi-browse _syfala._tcp --resolve HTTP control In order to build a target with HTTP support , you can add the --http flag to the command line: syfala examples/fm.dsp --linux --http After loading a DSP target with the syfala-load command (or manually), the host application will create a HTTP server allowing users to control the Faust DSP parameters remotely (given that you are on the same network as your FPGA board). At runtime, when executed, the application will print the device's current network IP (IPv4), and the port used by the HTTP server. You can then use any web browser , and control the application by entering the server's URL, for example http://192.168.0.1:5510 OSC control In order to build a target with OSC support , you can add the --osc flag to the command line: syfala examples/fm.dsp --linux --osc Note: your Faust .dsp file must also contain this line in order to enable OSC support: declare options \"[osc:on]\"; In parallel, the Host application will also create an Open Sound Control-compliant UDP server , and print its send/receive ports when executed. You can then control remotely the Faust DSP parameters by sending OSC messages like so: /virtualAnalog/lfoRange 2000 /virtualAnalog/oscFreq 500 ... More on: https://faustdoc.grame.fr/manual/osc/ MIDI control In order to build a target with MIDI support , you can add the --midi flag to the command line: syfala examples/fm.dsp --linux --midi Note: your Faust .dsp file must also contain this line in order to enable MIDI support: declare options \"[midi:on]\"; The Zybo boards have a Host USB port , located next to the switches. It can be used to connect a MIDI device and map its controls accordingly. No additional driver configuration is needed, but the board needs to be powered from an external power supply source : The supply must use a center-positive 2.1mm internal-diameter plug and deliver between 4.5V to 5.5V DC. It should also be able to output at least 2.5 A (12.5 Watts) in order to support power-hungry Zynq projects and external peripherals. To use an external supply with a barrel jack, plug it into the power jack (J17), set jumper JP6 to \u201cWALL\u201d, and then set SW4 to \u201cON\u201d. You'll also have to put a shorting jumper on JP2 ( HOST ), next to the USB port. The Faust midi-mapping process is explained here: https://faustdoc.grame.fr/manual/midi/ Wi-Fi Wi-Fi is handled by iwd (provided you have an USB dongle, or the appropriate additional hardware, which Zybo boards do not possess natively), the available commands are: # List your available wifi device(s), look for wlan0 iwctl device list # If you don't know the SSID of your network, you can run a scan and retrieve a list of all the detected networks: iwctl station wlan0 scan && iwctl station wlan0 get-networks # To connect to a network (use connect-hidden if it is a private network): iwctl station wlan0 connect <SSID> more on: https://wiki.alpinelinux.org/wiki/Wi-Fi Autologin / Autostart DSP target In order to autologin as root on the board, you have to edit the file /etc/inittab like the following: #ttyPS0::respawn:/sbin/getty -L ttyPS0 115200 vt100 # For autologin (as root): comment out the previous line and uncomment the next one: ttyPS0::respawn:/sbin/mingetty --autologin root --noclear ttyPS0 115200 vt100 To autostart a DSP target on boot , create a .start file in /etc/local.d , for example /etc/local.d/virtualAnalog.start : #!/bin/sh syfala-load virtualAnalog Execute chmod 755 /etc/local.d/virtualAnalog . That's it!","title":"Embedded Linux"},{"location":"tutorials/embedded-linux-getting-started/#syfala-linux-getting-started","text":"","title":"syfala-linux getting started"},{"location":"tutorials/embedded-linux-getting-started/#requirements","text":"Xilinx toolchain version > 2022.2 An available SD card The following Linux packages installed on your machine: gcc-arm-none-eabi gnutls-dev bison flex libssl-dev bc u-boot-tools cpio libyaml-dev curl kmod squashfs-tools qemu-user-static","title":"Requirements"},{"location":"tutorials/embedded-linux-getting-started/#building","text":"","title":"Building"},{"location":"tutorials/embedded-linux-getting-started/#available-commands","text":"","title":"Available commands"},{"location":"tutorials/embedded-linux-getting-started/#from-scratch","text":"First , a regular syfala project has to be built with the following options: syfala examples/virtualAnalog.dsp --linux The --linux option is used for compiling the host-side ( ARM ) application with the linux-specific source files (otherwise, it would be compiling the standard baremetal one). After synthesis , the script will detect that you don't currently have a linux build, which is required for building the application, and will download and build everything for you, you'll just have to flash it to your formatted SD card afterwards","title":"From scratch"},{"location":"tutorials/embedded-linux-getting-started/#outputs","text":"The build outputs are located in the build-linux/output directory, with two distinct boot and root subdirectories, which then will have to be be flashed on the first and second partitions of your SD card.","title":"Outputs"},{"location":"tutorials/embedded-linux-getting-started/#usage","text":"","title":"Usage"},{"location":"tutorials/embedded-linux-getting-started/#formatting-the-sd-card","text":"The SD card has to be formatted like so: 1st partition: FAT32 2nd partition: ext4 (Linux filesystem) There are many ways to achieve this, for instance: # you can just replace </dev/...> with your SD device, e.g: /dev/sda or /dev/mmcblk0 sudo parted /dev/... --script -- mklabel msdos sudo parted /dev/... --script -- mkpart primary fat32 1MiB 128MiB sudo parted /dev/... --script -- mkpart primary ext4 128MiB 100% sudo parted /dev/... --script -- set 1 boot on sudo parted /dev/... --script -- set 1 lba on sudo mkfs.vfat /dev/device-partition-1 # e.g. /dev/sda1 sudo mkfs.ext4 /dev/device-partition-2 # e.g. /dev/sda2 sudo parted /dev/... --script print","title":"Formatting the SD card"},{"location":"tutorials/embedded-linux-getting-started/#flashing-boot-root-partitions","text":"# In case your SD device is /dev/sda # 1. Copying boot partition files sudo mount /dev/sda1 /mnt sudo cp -r build-linux/output/boot/* /mnt sync sudo umount /mnt # 2. Copying root partition contents sudo mount /dev/sda2 /mnt sudo cp -r ~/Repositories/syfala/dev/main/build-linux/root/alpine-3.19.1/alpine-root/* . # This might take a while... sync sudo umount /mnt","title":"Flashing boot &amp; root partitions"},{"location":"tutorials/embedded-linux-getting-started/#booting","text":"Once flashed, just insert the SD card in your device's socket, make also sure it is configured to boot on SD (For the Zybo boards, you'll have to place a shorting jumper on SD instead of JTAG / QSPI ).","title":"Booting"},{"location":"tutorials/embedded-linux-getting-started/#connecting","text":"You can still connect through the ttyUSB Serial Port , or with SSH . for Serial Port connection, check that devices /dev/ttyUSB0 and /dev/ttyUSB1 are present on your host and use a serial communication program with following configuration: device /dev/ttyUSB1 , 115200 8N1 (115200 bits/second, one start bit, eight (8) data bits, no (N) parity bit, and one (1) stop bit), no hardware flow control and no software flow control. If hardware flow control is enable, the serial connection will not behave properly. for instance when using minicom: minicom -b 115200 -D/dev/ttyUSB1 -8 (check hardware flow control in minicom, ctrl-A Z). Linux booting console will appear. A login prompt will appear as soon as the booting process has completed: Welcome to Alpine Linux 3.17 Kernel 6.6.0-xilinx on an armv7l (/dev/ttyPS0) syfala login: for SSH connection, make sure that you are connected on the same network as your device's, get its IP address by serial connection as explained above and log as root: ssh root@192.168.0.1 .","title":"Connecting"},{"location":"tutorials/embedded-linux-getting-started/#loginusers","text":"The rootfs has the same structure as any Linux build. All DSP builds are located in the /root/ directory The password required to login as root is syfala","title":"Login/users"},{"location":"tutorials/embedded-linux-getting-started/#faust-dsp-builds","text":"All the DSP builds made with the syfala toolchain are placed in the /root directory by default. For instance, if you make a build from the virtualAnalog.dsp file , the bitstream / application outputs will be located in: /root/virtualAnalog/bitstream.bin /root/virtualAnalog/application.elf You can then use the syfala-load <target> [--list | --help] utility command (e.g. syfala-load virtualAnalog ), which will take care of loading the bitstream and executing the app properly. You can also do all of that manually of course: first, load the bitstream by entering the following command line: fpgautil -b /root/virtualAnalog/bitstream.bin and then execute the Host application like you would normally do with a Linux binary: cd /root/virtualAnalog ./application.elf If you wish to add another build to the SD card, you just have to re-run the syfala toolchain normally on your computer, with the --linux option. Your previous builds won't be erased or modified. syfala examples/fm.dsp --linux Once the build is complete, you will have two distinct project directories in your build-linux/root/alpine-3.19.1/alpine-root/ directory: root/virtualAnalog root/fm You will then have to re-flash your SD card to update the root partition , or directly copy the directory through ssh (e.g. with the scp command).","title":"Faust DSP builds"},{"location":"tutorials/embedded-linux-getting-started/#getting-the-devices-ip-port-from-avahi-for-network-based-control","text":"Once a DSP target is loaded with the syfala-load command, an avahi service is automatically started in a separate thread. If your desktop machine is on the same network as the FPGA board, and you have avahi installed & running, you should be able to retrieve the FPGA board's IP address and port required for the HTTP/OSC controls. You can use the avahi-browse command in order to do so: avahi-browse _syfala._tcp --resolve","title":"Getting the device's IP &amp; port from avahi (for network-based control)"},{"location":"tutorials/embedded-linux-getting-started/#http-control","text":"In order to build a target with HTTP support , you can add the --http flag to the command line: syfala examples/fm.dsp --linux --http After loading a DSP target with the syfala-load command (or manually), the host application will create a HTTP server allowing users to control the Faust DSP parameters remotely (given that you are on the same network as your FPGA board). At runtime, when executed, the application will print the device's current network IP (IPv4), and the port used by the HTTP server. You can then use any web browser , and control the application by entering the server's URL, for example http://192.168.0.1:5510","title":"HTTP control"},{"location":"tutorials/embedded-linux-getting-started/#osc-control","text":"In order to build a target with OSC support , you can add the --osc flag to the command line: syfala examples/fm.dsp --linux --osc Note: your Faust .dsp file must also contain this line in order to enable OSC support: declare options \"[osc:on]\"; In parallel, the Host application will also create an Open Sound Control-compliant UDP server , and print its send/receive ports when executed. You can then control remotely the Faust DSP parameters by sending OSC messages like so: /virtualAnalog/lfoRange 2000 /virtualAnalog/oscFreq 500 ... More on: https://faustdoc.grame.fr/manual/osc/","title":"OSC control"},{"location":"tutorials/embedded-linux-getting-started/#midi-control","text":"In order to build a target with MIDI support , you can add the --midi flag to the command line: syfala examples/fm.dsp --linux --midi Note: your Faust .dsp file must also contain this line in order to enable MIDI support: declare options \"[midi:on]\"; The Zybo boards have a Host USB port , located next to the switches. It can be used to connect a MIDI device and map its controls accordingly. No additional driver configuration is needed, but the board needs to be powered from an external power supply source : The supply must use a center-positive 2.1mm internal-diameter plug and deliver between 4.5V to 5.5V DC. It should also be able to output at least 2.5 A (12.5 Watts) in order to support power-hungry Zynq projects and external peripherals. To use an external supply with a barrel jack, plug it into the power jack (J17), set jumper JP6 to \u201cWALL\u201d, and then set SW4 to \u201cON\u201d. You'll also have to put a shorting jumper on JP2 ( HOST ), next to the USB port. The Faust midi-mapping process is explained here: https://faustdoc.grame.fr/manual/midi/","title":"MIDI control"},{"location":"tutorials/embedded-linux-getting-started/#wi-fi","text":"Wi-Fi is handled by iwd (provided you have an USB dongle, or the appropriate additional hardware, which Zybo boards do not possess natively), the available commands are: # List your available wifi device(s), look for wlan0 iwctl device list # If you don't know the SSID of your network, you can run a scan and retrieve a list of all the detected networks: iwctl station wlan0 scan && iwctl station wlan0 get-networks # To connect to a network (use connect-hidden if it is a private network): iwctl station wlan0 connect <SSID> more on: https://wiki.alpinelinux.org/wiki/Wi-Fi","title":"Wi-Fi"},{"location":"tutorials/embedded-linux-getting-started/#autologin-autostart-dsp-target","text":"In order to autologin as root on the board, you have to edit the file /etc/inittab like the following: #ttyPS0::respawn:/sbin/getty -L ttyPS0 115200 vt100 # For autologin (as root): comment out the previous line and uncomment the next one: ttyPS0::respawn:/sbin/mingetty --autologin root --noclear ttyPS0 115200 vt100 To autostart a DSP target on boot , create a .start file in /etc/local.d , for example /etc/local.d/virtualAnalog.start : #!/bin/sh syfala-load virtualAnalog Execute chmod 755 /etc/local.d/virtualAnalog . That's it!","title":"Autologin / Autostart DSP target"},{"location":"tutorials/faust-getting-started/","text":"Getting started with syfala and Faust Introduction This tutorial is intended for beginner -users with no background in FPGA or C++ development. Only basic knowledge of Linux and using the terminal is necessary. Prior experience using the Faust language is also preferable, but not required. Minimum hardware/software requirements Linux system (preferably Ubuntu 18.04 or higher, Debian-based or Archlinux-based distributions in general). 16GB of RAM (32 is recommended for bigger DSP programs). 100 GB of free disk space (for AMD-Xilinx tools installation) One of the following development boards: Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board Objectives In this tutorial, we will cover the essential topics to get started with the Faust programming language , syfala , and audio programming on FPGAs in general. We will start by briefly presenting all of these programs and environments, and then we will get our hands on a very concrete audio program example that we're going to build, flash on our FPGA development board, and control remotely, using different protocols, such as MIDI , OSC and HTTP . Faust Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. created at the GRAME-CNCM Research Department . In order to get you started using Faust, we recommend that you follow this tutorial : https://faustdoc.grame.fr/manual/quick-start Syfala About syfala (and FPGAs) Syfala is a set of command-line tools & scripts aiming to facilitate audio programming on FPGAs . It currently targets AMD-Xilinx devices, such as the Digilent Zybo Z7-10 & Z7-20 , or the Genesys ZU-3EG . It takes a Faust .dsp file or a C++ .cpp file as input, and then configures and calls all the AMD-Xilinx softwares that will compile all the required binaries to be flashed on device. The repository itself is composed of a few different elements: Command-line interface scripts ( syfala.tcl ). Faust architecture files , for interfacing with High Level Synthesis (HLS). Tcp scripts , used to configure and call the AMD-Xilinx softwares, such as Vitis HLS, Vivado, Vitis... Baremetal/Linux C++ code , for the ARM control executable. VHDL code : custom i\u00b2s implementations. Other types of scripts (for preprocessing, Makefile, Embedded Linux...) Installing the toolchain Dependencies Please follow the instructions in the file dependencies.md in order to install the AMD-Xilinx toolchain and various other dependencies. Installing Syfala git clone https://github.com/inria-emeraude/syfala.git syfala cd syfala make install You'll also have to add the following environment variable to your shell resource file (~/. bashrc / ~/. zshrc ) export XILINX_ROOT_DIR=/my/path/to/Xilinx/root/directory where XILINX_ROOT_DIR is the root directory where all of the AMD-Xilinx tools ( Vivado , Vitis , Vitis_HLS ) are installed. Your first example Building syfala <faust-file.dsp> [options] # Depending on the development board that you have, the command will be: syfala examples/faust/virtualAnalog.dsp --board Z10 --board Z20 --board GENESYS This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on your board. Under the hood, syfala will follow multiple steps, which you'll be able to monitor from the console log: 1 - Sources It will call Faust to generate the C++ code from the virtualAnalog.dsp file, with a custom-made syfala architecture file . You'll be able to see the resulting code in build/syfala_ip/syfala_ip_preprocessed.cpp . 2 - HLS Once the C++ code is generated, it will call Vitis HLS , which will translate it into a self-contained Hardware Description Language ( HDL ) program, which we're going in this tutorial to call the DSP kernel . The resulting code of this kernel can be viewed in the build/syfala_ip/syfala/impl/vhdl/syfala.vhd VHDL file. 3 - Project Here, the DSP kernel generated by Vitis HLS is going to be imported into a more global Vivado design , which will include the processing system (PS), our custom-made Integrated Interchip Sound ( i\u00b2s ) transceiver, and various other modules as well. The resulting code can be viewed in build/syfala_project/syfala_project.gen/sources_1/bd/main/hdl/main_wrapper.vhd 4 - Synthesis & implementation From here, Vivado will 'compile' the project's final design into what we call a bitstream , which is a hardware configuration file: it includes the description of the hardware logic, routing, and initial values for both registers and on-chip memory (e.g. LUT). 5 - ARM control executable Finally, we will also need to cross-compile an ARM elf executable to take care of all initialization and control-rate computations, which are done on the CPU, and exchanged with the DSP kernel using a specific set of buses. Reading performance reports If the build went well, you should be able to see on your terminal a recap of the build's configuration and an overview of its performance reports . Since the HLS report is only an estimate , the Vivado summary is the one that you should really pay attention to. virtualAnalog Z20 - DSP: 15% (35) - Reg: 9% (9730) - LUT: 16% (8820) - BRAM: 0% (0) Tot. 344 Cycles, 2.799us Max. 2604 Cycles, 20,8333us Lat. 13% Resources Here we can see that, on our Zybo Z7-20 development board, the final design doesn't take a lot of FPGA resources, so there's potentially room to add more cool stuff to our Faust program, if the latency is sufficiently low as well. Latency The report shows that the DSP kernel 's computations are done in 2.799 microseconds (344 FPGA clock cycles at 122 MHz): that is way below the maximum allowed for the computation of a single sample , which is defined by the reciprocal of the sample-rate ( 1/48000 in our case, which equals to 20,8333 microseconds). Exporting and re-importing your builds Before flashing, or doing anything else, it's generally a good idea to save and export your build outputs , especially when compilation times are really long, like ours. You can do this with the following syfala command : syfala export my-faust-virtual-analog-build # output in 'export/my-faust-virtual-analog-build.zip' The resulting .zip file is then going to be available in the repository's export directory. Later, you'll be able to re-import it by doing: syfala import export/my-faust-virtual-analog-build.zip Flashing Now we have our program fully compiled and exported, we can try it on our development Board. In order to do so, two options: Flash it from USB (with JTAG ), by connecting an USB cable to the board's UART port . Flash it from a bootable SD card . Hardware configuration In both cases, you'll have first to make sure that the board is set up with this configuration: Power select jumper (JP6) should be on USB Board should be connected ( UART PROG port ) to your machine with a micro-USB to USB cable. Switches SW0, SW1, SW2, SW3 should be down The audio input is LINE IN (blue), not ~~MIC IN~~. The audio output is the black HPH OUT jack. USB (JTAG) Hardware configuration: jumper JP5 should be on JTAG . Board should be powered up with SW4 . You can then quickly flash your program by entering the following syfala command from your terminal: syfala flash Keep in mind that when you shutdown your device and power it up again, it won't start your program again automatically (because it is not kept in memory), so you'll have to enter the syfala flash command again. This is why working with SD cards is going to be a better solution if you have the need to reload your program every time your power up the board. SD card Jumper JP5 should be on SD . SD card should have a FAT32 bootable partition . To generate the bootable binary file boot.bin , you can add the --boot flag to your syfala command : syfala examples/faust/virtualAnalog.dsp --board Z20 --boot It won't re-compile the whole project, it will just take the hardware and software outputs of your build and package them into a single bootable binary file ( boot.bin ), which you'll find in the build/sw_export directory. You can then just copy this file into your SD card, and insert it in the board's SD card socket, and then power the board up with SW4 . Monitoring and controlling the board remotely Once your build is flashed on your board, you'll first want to make sure that the program has been loaded and executed properly . You can obviously plug in a headset or a pair of speakers to check its audio output, but there are also a couple of ways of getting debug information, which you'll need in case the program is not working the way it is supposed to: LEDs Right after flashing your build, you can directly look at the board's LD12 LED, which is supposed to turn green when a bitstream has been properly loaded . Then, you can look at the LD5 RGB LED , which will go from blue to green during the ARM control program execution. Audio will usually start right after this LED turns green. If an error occurs, and LD12 is still off, or LD5 turns red , the next step would be to check the board's console output, which is accessible through UART. UART console In order to view the board's console output, you will need to install a serial device i/o tool , such as minicom or tio . For this tutorial, we will use tio . Once the board is connected with an USB cable ( PROG UART port ) to your laptop or desktop computer, you can enter the following command: tio -b 115200 /dev/ttyUSB1 This will tell tio to connect to the ttyUSB1 serial device interface with a baud rate of 115200 . Once it is done and the board has been powered-up again, you should see debug information being displayed on the console. Remote control of Faust parameters USB-UART control All of the user-interface elements declared in the Faust DSP code are controllable. In baremetal mode, the preferred way of doing this remotely from your machine would be using the available GUI to Serial interface, that you can start with the following command, once the DSP program is running on your board: syfala start-gui Syfala should now be building the user-interface after having retrieved the .dsp file's control parameters, and display it with a GTK interface when it's ready. You should now be able to play with the different buttons , sliders and knobs that have been defined in your Faust file. Now, GTK-based sliders and buttons are perfectly fine for testing your program, but you'll probably want at some point to have a nicer way to control its parameters, by using for instance MIDI or OSC interfaces. For now, in baremetal mode, it is not possible (yet) to plug a MIDI controller directly on the board's USB port and control your Faust parameters, because MIDI-USB baremetal drivers are unfortunately not yet implemented in syfala. The same goes for Ethernet-OSC. To remedy this problem, we offer at the moment two solutions : The Embedded Linux for syfala ( tutorials/embedded-linux-getting-started.md ) On Linux , MIDI, OSC & HTTP libraries are available, and ready-to-use with syfala. MIDI , OSC , HTTP layers on top of the Serial interface . MIDI, OSC & HTTP interfaces will be used on your machine, and translated/channeled into the Serial interface to be transmitted to the board. This is not ideal and will introduce some more control latency to the setup, but is easy to use. MIDI control In order to build a target with MIDI-Serial support, you can add the --midi flag to the command line, and reload the start-gui command: syfala examples/faust/virtualAnalogMIDI.dsp --board Z20 --midi syfala start-gui You'll also have to explicitly map in your Faust code the controls (sliders, knobs, etc.) to a MIDI control element (note, cc, pressure, etc.). An example of MIDI-mapping can be viewed in examples/faust/virtualAnalogMIDI.dsp , and the Faust MIDI-mapping process is fully explained here : https://faustdoc.grame.fr/manual/midi OSC control In order to build a target with OSC support , you can add the --osc flag to the command line: syfala examples/faust/virtualAnalog.dsp --board Z20 --osc syfala start-gui The GUI control application will create an Open Sound Control-compliant UDP server . You'll be then able to control remotely the Faust DSP parameters by sending OSC messages like so: /virtualAnalog/lfoRange 2000 /virtualAnalog/oscFreq 500 etc. More on: https://faustdoc.grame.fr/manual/osc HTTP control In order to build a target with HTTP support , you can add the --http flag to the command line: syfala examples/faust/virtualAnalog.dsp --board Z20 --http syfala start-gui The GUI control application will create a HTTP server allowing users to control the Faust DSP parameters remotely (given that you are on the same network as your FPGA board). At runtime, when executed, the application will print the device's current network IP (IPv4), and the port used by the HTTP server. You can then use any web browser , and control the application by entering the server's URL, for example http://192.168.0.1:5510 SPI-based controllers [...] Going further Embedded Linux Note: only available for Zybo Z7-10/Z7-20 boards (Genesys not yet supported) . Starting from syfala 0.8 , you can choose to build our custom-made embedded Linux , which will provide, in addition to all the things an OS has to offer (SSH control over Ethernet or Wi-Fi, package manager, etc.), the following features: No latency cost (the DSP kernel still dwells in the Programmable Logic) On-the-fly FPGA reprogramming from Linux (with no need to reboot or re-login). On-board USB-MIDI control (from the board's USB OTG port). Direct OSC/HTTP control , pre-mapped to the Faust DSP program's user-defined GUI elements (sliders, buttons, checkboxes, etc.). From the syfala command line interface, all you need to do is add the --linux flag: syfala examples/virtualAnalog.dsp --linux For the rest of the procedure, you can follow the linux getting-started tutorial Using syfala with C++ If you'd rather write your DSP code directly in C++, or you have a more imperative need for performance and optimization, you can follow our C++ tutorial here (advanced users).","title":"Faust tutorial"},{"location":"tutorials/faust-getting-started/#getting-started-with-syfala-and-faust","text":"","title":"Getting started with syfala and Faust"},{"location":"tutorials/faust-getting-started/#introduction","text":"This tutorial is intended for beginner -users with no background in FPGA or C++ development. Only basic knowledge of Linux and using the terminal is necessary. Prior experience using the Faust language is also preferable, but not required.","title":"Introduction"},{"location":"tutorials/faust-getting-started/#minimum-hardwaresoftware-requirements","text":"Linux system (preferably Ubuntu 18.04 or higher, Debian-based or Archlinux-based distributions in general). 16GB of RAM (32 is recommended for bigger DSP programs). 100 GB of free disk space (for AMD-Xilinx tools installation) One of the following development boards: Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board","title":"Minimum hardware/software requirements"},{"location":"tutorials/faust-getting-started/#objectives","text":"In this tutorial, we will cover the essential topics to get started with the Faust programming language , syfala , and audio programming on FPGAs in general. We will start by briefly presenting all of these programs and environments, and then we will get our hands on a very concrete audio program example that we're going to build, flash on our FPGA development board, and control remotely, using different protocols, such as MIDI , OSC and HTTP .","title":"Objectives"},{"location":"tutorials/faust-getting-started/#faust","text":"Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. created at the GRAME-CNCM Research Department . In order to get you started using Faust, we recommend that you follow this tutorial : https://faustdoc.grame.fr/manual/quick-start","title":"Faust"},{"location":"tutorials/faust-getting-started/#syfala","text":"","title":"Syfala"},{"location":"tutorials/faust-getting-started/#about-syfala-and-fpgas","text":"Syfala is a set of command-line tools & scripts aiming to facilitate audio programming on FPGAs . It currently targets AMD-Xilinx devices, such as the Digilent Zybo Z7-10 & Z7-20 , or the Genesys ZU-3EG . It takes a Faust .dsp file or a C++ .cpp file as input, and then configures and calls all the AMD-Xilinx softwares that will compile all the required binaries to be flashed on device. The repository itself is composed of a few different elements: Command-line interface scripts ( syfala.tcl ). Faust architecture files , for interfacing with High Level Synthesis (HLS). Tcp scripts , used to configure and call the AMD-Xilinx softwares, such as Vitis HLS, Vivado, Vitis... Baremetal/Linux C++ code , for the ARM control executable. VHDL code : custom i\u00b2s implementations. Other types of scripts (for preprocessing, Makefile, Embedded Linux...)","title":"About syfala (and FPGAs)"},{"location":"tutorials/faust-getting-started/#installing-the-toolchain","text":"","title":"Installing the toolchain"},{"location":"tutorials/faust-getting-started/#dependencies","text":"Please follow the instructions in the file dependencies.md in order to install the AMD-Xilinx toolchain and various other dependencies.","title":"Dependencies"},{"location":"tutorials/faust-getting-started/#installing-syfala","text":"git clone https://github.com/inria-emeraude/syfala.git syfala cd syfala make install You'll also have to add the following environment variable to your shell resource file (~/. bashrc / ~/. zshrc ) export XILINX_ROOT_DIR=/my/path/to/Xilinx/root/directory where XILINX_ROOT_DIR is the root directory where all of the AMD-Xilinx tools ( Vivado , Vitis , Vitis_HLS ) are installed.","title":"Installing Syfala"},{"location":"tutorials/faust-getting-started/#your-first-example","text":"","title":"Your first example"},{"location":"tutorials/faust-getting-started/#building","text":"syfala <faust-file.dsp> [options] # Depending on the development board that you have, the command will be: syfala examples/faust/virtualAnalog.dsp --board Z10 --board Z20 --board GENESYS This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on your board. Under the hood, syfala will follow multiple steps, which you'll be able to monitor from the console log:","title":"Building"},{"location":"tutorials/faust-getting-started/#1-sources","text":"It will call Faust to generate the C++ code from the virtualAnalog.dsp file, with a custom-made syfala architecture file . You'll be able to see the resulting code in build/syfala_ip/syfala_ip_preprocessed.cpp .","title":"1 - Sources"},{"location":"tutorials/faust-getting-started/#2-hls","text":"Once the C++ code is generated, it will call Vitis HLS , which will translate it into a self-contained Hardware Description Language ( HDL ) program, which we're going in this tutorial to call the DSP kernel . The resulting code of this kernel can be viewed in the build/syfala_ip/syfala/impl/vhdl/syfala.vhd VHDL file.","title":"2 - HLS"},{"location":"tutorials/faust-getting-started/#3-project","text":"Here, the DSP kernel generated by Vitis HLS is going to be imported into a more global Vivado design , which will include the processing system (PS), our custom-made Integrated Interchip Sound ( i\u00b2s ) transceiver, and various other modules as well. The resulting code can be viewed in build/syfala_project/syfala_project.gen/sources_1/bd/main/hdl/main_wrapper.vhd","title":"3 - Project"},{"location":"tutorials/faust-getting-started/#4-synthesis-implementation","text":"From here, Vivado will 'compile' the project's final design into what we call a bitstream , which is a hardware configuration file: it includes the description of the hardware logic, routing, and initial values for both registers and on-chip memory (e.g. LUT).","title":"4 - Synthesis &amp; implementation"},{"location":"tutorials/faust-getting-started/#5-arm-control-executable","text":"Finally, we will also need to cross-compile an ARM elf executable to take care of all initialization and control-rate computations, which are done on the CPU, and exchanged with the DSP kernel using a specific set of buses.","title":"5 - ARM control executable"},{"location":"tutorials/faust-getting-started/#reading-performance-reports","text":"If the build went well, you should be able to see on your terminal a recap of the build's configuration and an overview of its performance reports . Since the HLS report is only an estimate , the Vivado summary is the one that you should really pay attention to. virtualAnalog Z20 - DSP: 15% (35) - Reg: 9% (9730) - LUT: 16% (8820) - BRAM: 0% (0) Tot. 344 Cycles, 2.799us Max. 2604 Cycles, 20,8333us Lat. 13%","title":"Reading performance reports"},{"location":"tutorials/faust-getting-started/#resources","text":"Here we can see that, on our Zybo Z7-20 development board, the final design doesn't take a lot of FPGA resources, so there's potentially room to add more cool stuff to our Faust program, if the latency is sufficiently low as well.","title":"Resources"},{"location":"tutorials/faust-getting-started/#latency","text":"The report shows that the DSP kernel 's computations are done in 2.799 microseconds (344 FPGA clock cycles at 122 MHz): that is way below the maximum allowed for the computation of a single sample , which is defined by the reciprocal of the sample-rate ( 1/48000 in our case, which equals to 20,8333 microseconds).","title":"Latency"},{"location":"tutorials/faust-getting-started/#exporting-and-re-importing-your-builds","text":"Before flashing, or doing anything else, it's generally a good idea to save and export your build outputs , especially when compilation times are really long, like ours. You can do this with the following syfala command : syfala export my-faust-virtual-analog-build # output in 'export/my-faust-virtual-analog-build.zip' The resulting .zip file is then going to be available in the repository's export directory. Later, you'll be able to re-import it by doing: syfala import export/my-faust-virtual-analog-build.zip","title":"Exporting and re-importing your builds"},{"location":"tutorials/faust-getting-started/#flashing","text":"Now we have our program fully compiled and exported, we can try it on our development Board. In order to do so, two options: Flash it from USB (with JTAG ), by connecting an USB cable to the board's UART port . Flash it from a bootable SD card .","title":"Flashing"},{"location":"tutorials/faust-getting-started/#hardware-configuration","text":"In both cases, you'll have first to make sure that the board is set up with this configuration: Power select jumper (JP6) should be on USB Board should be connected ( UART PROG port ) to your machine with a micro-USB to USB cable. Switches SW0, SW1, SW2, SW3 should be down The audio input is LINE IN (blue), not ~~MIC IN~~. The audio output is the black HPH OUT jack.","title":"Hardware configuration"},{"location":"tutorials/faust-getting-started/#usb-jtag","text":"Hardware configuration: jumper JP5 should be on JTAG . Board should be powered up with SW4 . You can then quickly flash your program by entering the following syfala command from your terminal: syfala flash Keep in mind that when you shutdown your device and power it up again, it won't start your program again automatically (because it is not kept in memory), so you'll have to enter the syfala flash command again. This is why working with SD cards is going to be a better solution if you have the need to reload your program every time your power up the board.","title":"USB (JTAG)"},{"location":"tutorials/faust-getting-started/#sd-card","text":"Jumper JP5 should be on SD . SD card should have a FAT32 bootable partition . To generate the bootable binary file boot.bin , you can add the --boot flag to your syfala command : syfala examples/faust/virtualAnalog.dsp --board Z20 --boot It won't re-compile the whole project, it will just take the hardware and software outputs of your build and package them into a single bootable binary file ( boot.bin ), which you'll find in the build/sw_export directory. You can then just copy this file into your SD card, and insert it in the board's SD card socket, and then power the board up with SW4 .","title":"SD card"},{"location":"tutorials/faust-getting-started/#monitoring-and-controlling-the-board-remotely","text":"Once your build is flashed on your board, you'll first want to make sure that the program has been loaded and executed properly . You can obviously plug in a headset or a pair of speakers to check its audio output, but there are also a couple of ways of getting debug information, which you'll need in case the program is not working the way it is supposed to:","title":"Monitoring and controlling the board remotely"},{"location":"tutorials/faust-getting-started/#leds","text":"Right after flashing your build, you can directly look at the board's LD12 LED, which is supposed to turn green when a bitstream has been properly loaded . Then, you can look at the LD5 RGB LED , which will go from blue to green during the ARM control program execution. Audio will usually start right after this LED turns green. If an error occurs, and LD12 is still off, or LD5 turns red , the next step would be to check the board's console output, which is accessible through UART.","title":"LEDs"},{"location":"tutorials/faust-getting-started/#uart-console","text":"In order to view the board's console output, you will need to install a serial device i/o tool , such as minicom or tio . For this tutorial, we will use tio . Once the board is connected with an USB cable ( PROG UART port ) to your laptop or desktop computer, you can enter the following command: tio -b 115200 /dev/ttyUSB1 This will tell tio to connect to the ttyUSB1 serial device interface with a baud rate of 115200 . Once it is done and the board has been powered-up again, you should see debug information being displayed on the console.","title":"UART console"},{"location":"tutorials/faust-getting-started/#remote-control-of-faust-parameters","text":"","title":"Remote control of Faust parameters"},{"location":"tutorials/faust-getting-started/#usb-uart-control","text":"All of the user-interface elements declared in the Faust DSP code are controllable. In baremetal mode, the preferred way of doing this remotely from your machine would be using the available GUI to Serial interface, that you can start with the following command, once the DSP program is running on your board: syfala start-gui Syfala should now be building the user-interface after having retrieved the .dsp file's control parameters, and display it with a GTK interface when it's ready. You should now be able to play with the different buttons , sliders and knobs that have been defined in your Faust file. Now, GTK-based sliders and buttons are perfectly fine for testing your program, but you'll probably want at some point to have a nicer way to control its parameters, by using for instance MIDI or OSC interfaces. For now, in baremetal mode, it is not possible (yet) to plug a MIDI controller directly on the board's USB port and control your Faust parameters, because MIDI-USB baremetal drivers are unfortunately not yet implemented in syfala. The same goes for Ethernet-OSC. To remedy this problem, we offer at the moment two solutions : The Embedded Linux for syfala ( tutorials/embedded-linux-getting-started.md ) On Linux , MIDI, OSC & HTTP libraries are available, and ready-to-use with syfala. MIDI , OSC , HTTP layers on top of the Serial interface . MIDI, OSC & HTTP interfaces will be used on your machine, and translated/channeled into the Serial interface to be transmitted to the board. This is not ideal and will introduce some more control latency to the setup, but is easy to use.","title":"USB-UART control"},{"location":"tutorials/faust-getting-started/#midi-control","text":"In order to build a target with MIDI-Serial support, you can add the --midi flag to the command line, and reload the start-gui command: syfala examples/faust/virtualAnalogMIDI.dsp --board Z20 --midi syfala start-gui You'll also have to explicitly map in your Faust code the controls (sliders, knobs, etc.) to a MIDI control element (note, cc, pressure, etc.). An example of MIDI-mapping can be viewed in examples/faust/virtualAnalogMIDI.dsp , and the Faust MIDI-mapping process is fully explained here : https://faustdoc.grame.fr/manual/midi","title":"MIDI control"},{"location":"tutorials/faust-getting-started/#osc-control","text":"In order to build a target with OSC support , you can add the --osc flag to the command line: syfala examples/faust/virtualAnalog.dsp --board Z20 --osc syfala start-gui The GUI control application will create an Open Sound Control-compliant UDP server . You'll be then able to control remotely the Faust DSP parameters by sending OSC messages like so: /virtualAnalog/lfoRange 2000 /virtualAnalog/oscFreq 500 etc. More on: https://faustdoc.grame.fr/manual/osc","title":"OSC control"},{"location":"tutorials/faust-getting-started/#http-control","text":"In order to build a target with HTTP support , you can add the --http flag to the command line: syfala examples/faust/virtualAnalog.dsp --board Z20 --http syfala start-gui The GUI control application will create a HTTP server allowing users to control the Faust DSP parameters remotely (given that you are on the same network as your FPGA board). At runtime, when executed, the application will print the device's current network IP (IPv4), and the port used by the HTTP server. You can then use any web browser , and control the application by entering the server's URL, for example http://192.168.0.1:5510","title":"HTTP control"},{"location":"tutorials/faust-getting-started/#spi-based-controllers","text":"[...]","title":"SPI-based controllers"},{"location":"tutorials/faust-getting-started/#going-further","text":"","title":"Going further"},{"location":"tutorials/faust-getting-started/#embedded-linux","text":"Note: only available for Zybo Z7-10/Z7-20 boards (Genesys not yet supported) . Starting from syfala 0.8 , you can choose to build our custom-made embedded Linux , which will provide, in addition to all the things an OS has to offer (SSH control over Ethernet or Wi-Fi, package manager, etc.), the following features: No latency cost (the DSP kernel still dwells in the Programmable Logic) On-the-fly FPGA reprogramming from Linux (with no need to reboot or re-login). On-board USB-MIDI control (from the board's USB OTG port). Direct OSC/HTTP control , pre-mapped to the Faust DSP program's user-defined GUI elements (sliders, buttons, checkboxes, etc.). From the syfala command line interface, all you need to do is add the --linux flag: syfala examples/virtualAnalog.dsp --linux For the rest of the procedure, you can follow the linux getting-started tutorial","title":"Embedded Linux"},{"location":"tutorials/faust-getting-started/#using-syfala-with-c","text":"If you'd rather write your DSP code directly in C++, or you have a more imperative need for performance and optimization, you can follow our C++ tutorial here (advanced users).","title":"Using syfala with C++"}]}