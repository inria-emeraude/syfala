use std::fs::File;
use std::io::Read;
use std::{env, fs};

use serde_json::Value;

fn main() {
    // if HLS_ETHERNET_DATA_JSON_IGNORE=1 do not generate script
    if env::var("HLS_ETHERNET_DATA_JSON_IGNORE") == Ok("1".to_string()) {
        println!("HLS_ETHERNET_DATA_JSON_IGNORE=1, so not generating hls_const.rs.");
        println!("!!!! THIS SHOULD NOT ONLY BE USED FOR DEPENDENCY BUILDING! !!!!");
        return;
    }
    let mut s = String::new();
    s += "// ********************************************************************\n";
    s += "//                          IMPORTANT\n";
    s += "// This is automatically generated by build.rs, do not change manually\n";
    s += "// ********************************************************************\n\n\n";

    let path = match env::var("HLS_ETHERNET_DATA_JSON") {
        Ok(val) => val,
        Err(_) => {
            let path = "../../../build/ethernet_ip/ethernet/ethernet_data.json";
            println!("Warning! No HLS_ETHERNET_DATA_JSON set, falling back to default: '{path}'");
            path.to_string()
        }
    };
    println!("Parsing file '{}'...", path);
    // Open and read the JSON file
    let mut file = File::open(&path)
        .unwrap_or_else(|e| panic!("Failed to open file '{path}'! This gets generated by the HLS and contains the AXILite registers! Error {e}"));
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .unwrap_or_else(|e| panic!("Failed to read file '{path}', error {e}"));

    // Parse the JSON data
    let j: Value =
        serde_json::from_str(&contents).unwrap_or_else(|e| panic!("Failed to parse JSON: {e}"));
    // Process the registers
    let registers = &j["Interfaces"]["s_axi_control"]["registers"];
    for register in registers.as_array().expect("Invalid register format") {
        let description = &register["fields"][0]["description"]
            .as_str()
            .expect("Invalid description format");
        let name = &register["name"].as_str().expect("Invalid name format");
        let offset = &register["offset"]
            .as_str()
            .expect("offset Invalid")
            .trim_matches('"');

        s += &format!("/// {}\n", description);
        s += "#[allow(dead_code)]\n";
        s += &format!(
            "pub const AXI_LITE_{}: usize = {};\n",
            name.to_uppercase(),
            offset
        );
    }

    // Write the result to a file
    fs::write("src/hls_const.rs", s).expect("Failed to write file");
}
