\label{example}
\label{sec:example}
Imagine we want to implement on FPGA a filter-based sine wave oscillator. Such a sine wave is written in Faust in Fig.~\ref{fig:osc}, it is available in Syfala repository as program {\tt sinewave-biquad-inlined.dsp} of the {\tt examples} directory. There is one controller which selects the oscillator frequency. Note the {\tt ``[knob:1]''} meta data that indicates that this controller will be associated to the first knob in case of hardware interface.

The computation of {\tt th}, {\tt c} and {\tt s} are depending on the frequency value, hence we expect all these variables to be computed at control rate, hence on the ARM, not on the FPGA. On the other hand, the computation of {\tt nlf2} is performed at each sample (sample rate) and will be implemented on the FPGA.


\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/sinewave-biquad-inlined.dsp}
  \end{boxedminipage}
  \caption{Filter-based sine wave oscillator in Faust used for illustrating the compilation process (file {\tt sinewave-biquad-inlined.dsp} in {\tt examples} directory).}
  \label{fig:osc}
  \label{fig:biquad}
\end{figure}

The whole compilation can be done using the command:\\
{\tt syfala examples/sinewave-biquad-inlined.dsp}\\
but we will detail the different steps.

The first step of the compilation flow is to generate a C++ program from the Faust code, this is done by executing:\\
\verb#syfala examples/sinewave-biquad-inlined.dsp --arch --reset# \\
this command will generate {\tt syfala\_ip.cpp} and {\tt syfala\_application.cpp} files. All the generated files  are generated in the directory {\tt build/}. The \verb#--reset# options is mandatory if another project has already been compiled in the {\tt build} directory. Warning, the \verb#--reset# option will erase your previous compiled Syfala project.

The \verb#--arch# option generates the {\tt syfala\_ip.cpp} file in directory {\tt build/syfala\_ip/} and the {\tt syfala\_application.cpp} file in {\tt build/syfala\_application/}. Note that a file {\tt build/include/syconfig.hpp} is also created in which the parameters of the current design flow are saved (sample rate, board used, hard or software controller, etc.). From now on the {\tt build/sinewave-biquad-inlined.dsp} will be the default DSP program syfala is working on, hence the name of the {\tt .dsp} file do not have to be recalled at each syfala command.\\
~\\
\begin{boxedminipage}{1.03\textwidth}
  \small
\begin{verbatim}
syfala-github$ syfala examples/sinewave-biquad-inlined.dsp --arch --reset
[ INFO ] Running syfala toolchain script (v7) on Linux (5.4.0-126-generic)
[...]
[ INFO ] Generating Faust IP from Faust compiler & architecture file
[  OK  ] Generated /home/trisset/technical/syfala-github2/build/\
      syfala_ip/syfala_ip.cpp
[ ... ] 
[  OK  ] Generated /home/trisset/technical/syfala-github2/build/\
      syfala_application/syfala_application.cpp
[ ... ] 
[ INFO ] Script has been running for 00 minutes and 00 seconds
[  OK  ] Successful run!
\end{verbatim}
\end{boxedminipage}
~\\

\begin{figure}[ht] 
 \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/sinewave-biquad-inlined.cpp}
  \end{boxedminipage}
  \caption{Excerpt of {\tt syfala\_ip.cpp} C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the FPGA target.}
  \label{fig:oscCode}
  \label{fig:biquadCode}
\end{figure}

An excerpt of file {\tt syfala\_ip.cpp} is shown on Fig.~\ref{fig:oscCode}. One can first notice the structure {\tt mydsp} that is built for this example, the output  samples are computed by the {\tt computemydsp()} function. In this example, as the memory used is small, all variables are stored in Block Rams, hence declared here, in {\tt syfala\_ip.cpp}. By looking at the body of the {\tt syfala() function} (i.e. the ``main'' syfala IP function),  one can see that, at the very beginning,  the function {\tt instanceConstantsFromMemmydsp()} is executed (it copies the initialized constant {\tt fconst0} on the FPGA), then the {\tt computemydsp} is executed for all other samples. {\tt fRec} names are usually used for delay lines, the IOTA is used to implement delay line by circular buffers.

The second step of the compilation flow is to synthesize the Faust IP from the {\tt syfala\_ip.cpp} using {\tt vitis\_hls}, this is done by typing \verb#syfala --ip#.
The IP is generated in directory {\tt build/syfala\_ip/syfala}. The report of the HLS, indicating the size of the resulting IP and execution time in terms of FPGA cycles can be seen by typing {\tt syfala report}.
The execution time of the HLS is approximately 1 mn.\\
~\\
\begin{boxedminipage}{\textwidth}
  \small
\begin{verbatim}
syfala-github> syfala --ip
[ INFO ] Running syfala toolchain script (v7) on Linux (5.4.0-126-generic)
[....]
[ INFO ] Running Vitis HLS on file [...]/syfala-github/scripts/hls.tcl
****** Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2020.2 (64-bit)
[...]

[ INFO ] Script has been running for 00 minutes and 43 seconds
[  OK  ] Successful run!
syfala-github>
\end{verbatim}
\end{boxedminipage}
~\\

The next step is to synthesize the whole design that includes the Faust IP. For that, we need to build the bloc design. Usually, it's done a first time with the Vivado GUI and can be exported in .tcl or .vhd "Bloc Design" file to script the synthesis of the project. But we choose to write a script called {\tt syfala\_maker.tcl} that will directly generate this "Bloc Design" file. The advantage is that the bloc design can be dynamically changed. For example, it allow us to change the number of I2S channels on the transceiver and adapt the number of used GPIO and the internal routing just with a macro. We couldn't do such a thing with a fixed block design file.

Then, the synthesize of the project is done by executing \verb#syfala --project# and then \verb#syfala --syn#. The first command builds the {\tt syfala\_project.xpr} vivado project from the TCL files. The second command loads and then executes the {\tt syfala\_project.xpr} project in vivado to produce the bitstream. As a result, a  file {\tt main\_wrapper.xsa} is generated in {\tt build/hw\_export} directory, it corresponds to an archive containing both the FPGA bitstream and configuration of the {\em processing system} (i.e. the ARM subsystem). One important point here is that the {\tt syfala\_project.xpr} can be opened directly with Vivado 2020.2 GUI (by executing \verb#syfala --open-project#) and modified and re-synthesized. This can be useful for exploring other block designs (other parameters for the Faust IP for instance). The \verb#syfala --export# command allows you to save all generated files in an {\tt export} directory in order not to loose them when executing a command with \verb#--reset# option.\\

\begin{boxedminipage}{\textwidth}
  \small
\begin{verbatim}
syfala-github$ syfala --project
[ INFO ] Running syfala toolchain script (v7) on Linux (5.4.0-126-generic)
[...]
[ INFO ] Running Vivado on file /home/trisset/technical/syfala-github2/build/
     sources/project.tcl
****** Vivado v2020.2 (64-bit)
[...]
[ INFO ] Script has been running for 00 minutes and 26 seconds
[  OK  ] Successful run!

syfala-github$ syfala --syn
[ INFO ] Running syfala toolchain script (v7) on Linux (5.4.0-126-generic)
[...][ INFO ] Running Vivado on file /home/trisset/technical/syfala-github2/
   scripts/synthesis.tcl
****** Vivado v2020.2 (64-bit)
[...]
Waiting for synth_1 to finish...
[...]
[ INFO ] Script has been running for 08 minutes and 58 seconds
[  OK  ] Successful run!
syfala-github>
\end{verbatim}
\end{boxedminipage}
~\\

Then you have to compile the application file that will run on the ARM processor. This application file has been generated by the Faust compiler at the first step (i.e. \verb#--arch# option). It uses  the {\tt arm.cpp} architecture file as main file. Its re-uses many software components developed for the Faust ecosystem and uses also the drivers provided by Xilinx in {\tt vivado}. Then the {\tt application.tcl} script is executed with {\tt xsct} (Xilinx Software Command-line Tool) which is an an interactive and scriptable command-line interface to Xilinx {\tt vitis} (formerly Xilinx SDK).

~\\
\begin{boxedminipage}{1.01\textwidth}
  \small
\begin{lstlisting}
syfala-github> syfala --app
[ INFO ] Running syfala toolchain script (v7) on Linux (5.4.0-126-generic)
[...]
[ INFO ] Compiling Host control application
make -C ps7_cortexa9_0/libsrc/xilffs_v4_4/src -s include  "SHELL=/bin/sh" "COMPILER=arm-none-eabi-gcc"
   "ASSEMBLER=arm-none-eabi-as" "ARCHIVER=arm-none-eabi-ar" "COMPILER_FLAGS=  -O2 -c"
   "EXTRA_COMPILER_FLAGS=-mcpu=cortex-a9 -mfpu=vfpv3 -mfloat-abi=hard -nostartfiles -g -Wall -Wextra"
[...]
5:11:05 Build Finished (took 1s.713ms)
Finished building projects
[  OK  ] Finished building host application
[  OK  ] Copied application sources and .elf output to sw_export directory
[ INFO ] Script has been running for 00 minutes and 43 seconds
[  OK  ] Successful run!
[  OK  ] To see the build's full log: open 'syfala_log.txt' in the repository's
  root directory
syfala-github>
\end{lstlisting}
\end{boxedminipage}
~\\

An excerpt of file {\tt syfala\_application.cpp} is shown on Fig.~\ref{fig:oscARM}. One can see that the {\tt mydsp} class private fields are exactly the same as the structure {\tt mydsp} of the Faust IP (Fig.~\ref{fig:oscCode}). This allow us to have coherent view of the IP, either from inside the FPGA or from the ARM processor. 

\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/faust_v6_app.cpp}
  \end{boxedminipage}
  \caption{Excerpt of C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the ARM application target.}
  \label{fig:oscARM}
\end{figure}


One can see that the {\tt control} method of {\tt mydsp} on the ARM processor (Fig.~\ref{fig:oscARM}) corresponds to the computations of variables {\tt th}, {\tt c} and {\tt s} of the Faust program of Fig.~\ref{fig:osc}. As we expected, the control rate computations are executed on the ARM. Then the structure {\tt ARMcontroller} defines the functions {\tt sendControlToFPGA()} and {\tt controlFPGA()}.

The function {\tt sendControlToFPGA()} is using Xilinx driver functions for accessing {\tt s-axilite} port of the Faust IP (here {\tt fControl} and {\tt iControl} ports). The function {\tt controlFPGA()}  will first call {\tt \verb#fDSP->control()#} in order to get new values of the controllers from the hardware or software user interface, then it will call  {\tt sendControlFPGA()} to send these values to the Faust IP. {\tt sendControlFPGA()} uses the API provided by Xilinx to communicate between the ARM and the FPGA IP (\verb#XSyfala_Write_ARM[...]()# functions)

\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/faust_v6_app2.cpp}
  \end{boxedminipage}
  \caption{Excerpt of C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the ARM application target.}
  \label{fig:oscARM2}
\end{figure}

Finally, the generated program can be transferred to the FPGA board with the  \verb#syfala --flash# command (the Zybo board has to be plugged on a USB port of course, and a headphone should be used to hear the sounds). The control GUI is compiled with the \verb#syfala --gui# command, and then executed with \verb#syfala gui#. Once flashed, the {\tt syfala\_application} is launched automatically on the ARM and the bitstream is executing. The ARM has to boot first, so the {\tt enable\_RAM\_access} port (see figure~\ref{fig:body}) is used to indicate that the Syfala IP can start its computations.




