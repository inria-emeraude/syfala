<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A guide to the Syfala toolchain.">
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">

    
    <title>C++ tutorial - Syfala Documentation</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/nord.min.css">
        
    

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="../..">Syfala Documentation</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Manual <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../manual/dependencies/">Dependencies</a>
</li>

                        
                            
<li >
    <a href="../../manual/reference/">Reference</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorials <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../faust-getting-started/">Faust tutorial</a>
</li>

                        
                            
<li >
    <a href="../embedded-linux-getting-started/">Embedded Linux</a>
</li>

                        
                            
<li class="active">
    <a href="./">C++ tutorial</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../embedded-linux-getting-started/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="next" >
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#using-syfala-with-c">Using syfala with C++</a></li>
            <li class="second-level"><a href="#introduction">Introduction</a></li>
                
                <li class="third-level"><a href="#how-does-it-work">How does it work?</a></li>
                <li class="third-level"><a href="#pros">Pros:</a></li>
                <li class="third-level"><a href="#cons">Cons:</a></li>
            <li class="second-level"><a href="#code-structure">Code structure</a></li>
                
                <li class="third-level"><a href="#using-pre-made-examples">Using pre-made examples</a></li>
                <li class="third-level"><a href="#signal-types">Signal types</a></li>
                <li class="third-level"><a href="#audio-inputs-outputs">Audio inputs &amp; outputs</a></li>
                <li class="third-level"><a href="#top-level-interface">Top-level interface</a></li>
                <li class="third-level"><a href="#initialization">Initialization</a></li>
                <li class="third-level"><a href="#bypassmute-switches">Bypass/mute switches</a></li>
                <li class="third-level"><a href="#dsp-code">DSP code</a></li>
            <li class="second-level"><a href="#building-and-flashing-with-the-syfala-cli">Building and flashing with the syfala CLI</a></li>
                
            <li class="second-level"><a href="#verifying-code-with-c-simulation-csim">Verifying code with C simulation (CSIM)</a></li>
                
                <li class="third-level"><a href="#using-pre-defined-generic-templates">Using pre-defined generic templates:</a></li>
                <li class="third-level"><a href="#writing-your-own-csim">Writing your own CSIM</a></li>
            <li class="second-level"><a href="#optimizing-code">Optimizing code</a></li>
                
                <li class="third-level"><a href="#monitoring-latency-resource-utilization">Monitoring latency &amp; resource utilization</a></li>
                <li class="third-level"><a href="#using-optimization-directives-pragmas">Using optimization directives &amp; pragmas</a></li>
                <li class="third-level"><a href="#using-a-sample-block-configuration-multisample">Using a 'sample block' configuration (--multisample)</a></li>
            <li class="second-level"><a href="#sharing-processingcontrol-with-the-arm-executable">Sharing processing/control with the ARM executable</a></li>
                
                <li class="third-level"><a href="#basic-axi-lite-control-example">Basic AXI-Lite control example</a></li>
                <li class="third-level"><a href="#delay-line-axi-example-ddr-memory">Delay-line AXI example (DDR memory)</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="using-syfala-with-c">Using syfala with C++</h1>
<h2 id="introduction">Introduction</h2>
<p>While Faust is undoubtedly a nice and easy way to create complex and fully-controllable DSP programs on FPGAs, in some cases - where for instance balancing resource usage and latency becomes a critical issue - bypassing Faust and programming directly in C++ can become a more suitable solution.</p>
<h4 id="how-does-it-work">How does it work?</h4>
<p>Ordinarily, the easiest way to get started with <em>syfala</em> is to use <em>Faust</em> to generate the C++ code that is going to be fed to the <strong>High Level Synthesis</strong> (<strong>HLS</strong>) tool and turned into <strong>Hardware Description Language</strong> (HDL) code. The resulting DSP <em>kernel</em> (or <em>IP</em>: Intellectual Property) is then going to be added to a more global <em>design</em>, which will include the <strong>processing system</strong> (PS), our custom-made <strong>Integrated Interchip Sound</strong> (<em>i²s</em>) and various other modules as well.</p>
<p>Consequently - and since we're already using <em>HLS</em> - programming the DSP <em>kernel</em> directly in C++ is entirely possible, but remains a more complex solution, and won't offer the same user-friendly features that Faust is able to provide out-of-the-box.</p>
<h4 id="pros">Pros:</h4>
<ul>
<li>Better <strong>balance control</strong> between <strong>FPGA resource usage</strong> &amp; <strong>latency</strong>.</li>
<li>HLS-friendly/optimized code.</li>
<li>HLS libraries, pragmas &amp; tools.</li>
</ul>
<h4 id="cons">Cons:</h4>
<ul>
<li>Limited support of C++ features (up to <strong>C++14</strong>).</li>
<li>Complex HLS interfaces &amp; documentation.</li>
<li><strong>No out-of-the-box GUI/Serial</strong> control interface.</li>
<li>Data exchange with <strong>ARM</strong> through <em>AXI-Lite</em> or <em>DDR</em> memory has to be done manually.</li>
</ul>
<h2 id="code-structure">Code structure</h2>
<p>The following describes how to program a syfala DSP <em>kernel</em> using C++. It is intended for advanced users.</p>
<h3 id="using-pre-made-examples">Using pre-made examples</h3>
<p>To get an idea on how to program the DSP <em>kernel</em> in C++, you can refer to the <code>examples/cpp</code> directory in the <strong>syfala</strong> repository.</p>
<p>For this tutorial, we will build a simple <em>stereo gain</em> DSP kernel. The interface that we propose is pretty straightforward, but there a couple of things that still need to be explained in details:</p>
<h3 id="signal-types">Signal types</h3>
<p>In the global syfala FPGA design, audio signals are conveyed as streams of <strong>24-bits integers, by default</strong>. The bit width can be changed using the <code>--sample-width</code> flag in the <strong>syfala</strong> command line interface, but cannot be changed to single or double precision floating point types.  Since audio DSP programs are usually processing <code>float</code> or <code>double</code>-based signals, a few convenience functions and types have been added in the <code>syfala/utilities.hpp</code> header, which can be easily included in your C++ file:</p>
<pre><code class="language-c++">#include &lt;syfala/utilities.hpp&gt;
</code></pre>
<p>This header defines for instance the type <code>sy_ap_int</code>, as the following:</p>
<pre><code class="language-cpp">// include/syfala/utilities.hpp

using sy_ap_int = ap_int&lt;SYFALA_SAMPLE_WIDTH&gt;;
// note: the 'ap_int' (arbitrary precision integer) type is defined by Vitis_HLS in $XILINX_ROOT_DIR/Vitis_HLS/2022.2/include/ap_int.h
</code></pre>
<p>It also defines the following <strong>read/write convenience functions</strong> between <code>sy_ap_int</code> and <code>float</code> types. These will come in handy when reading and writing from/to the audio input/output ports.</p>
<pre><code class="language-cpp">// include/syfala/utilities.hpp

namespace Syfala::HLS {
/**
 * @brief ioreadf Read sy_ap_int as float
 * @param input sy_ap_int data input
 * @return floating-point conversion of input
 */
float ioreadf(sy_ap_int const&amp; input);
/**
 * @brief iowritef write floating point data to ap_int
 * top-level function output.
 * @param f float data input
 * @param output ap_int interface output.
 */
void iowritef(float f, sy_ap_int&amp; output);
}
</code></pre>
<p>You should also be able, from this file, to access some useful <em>compile-time</em> data, such as the <strong>current sample rate</strong>, or <strong>sample-width</strong> which are defined with the following <strong>macros</strong>: </p>
<pre><code class="language-cpp">#define SYFALA_SAMPLE_RATE 48000
#define SYFALA_SAMPLE_WIDTH 24
</code></pre>
<h3 id="audio-inputs-outputs">Audio inputs &amp; outputs</h3>
<p>First, in order to generate the <em>block design</em> that is going to be synthesized by <strong>Vivado</strong> and make the proper connections with <em>i²s</em>, <strong>syfala</strong> needs to be <strong>explicitly informed of the number of audio input/output</strong> channels that the DSP program is going to have. In our case, for the <em>stereo gain</em> example, we want <strong>2 inputs</strong> and <strong>2 outputs</strong>. To do so, in the current version of <strong>syfala</strong>, the following C macros need to be defined somewhere in the code:</p>
<pre><code class="language-cpp">// examples/cpp/templates/gain.cpp
#define INPUTS 2
#define OUTPUTS 2
</code></pre>
<p>It will inform the toolchain to use the following <strong>audio input and output ports</strong>, which will  be formatted like this in our final design:</p>
<ul>
<li><code>audio_in_#</code> (in our case, <code>audio_in_0</code> and <code>audio_in_1</code>)</li>
<li><code>audio_out_#</code> (in our case, <code>audio_out_0</code> and <code>audio_out_1</code>)</li>
</ul>
<h3 id="top-level-interface">Top-level interface</h3>
<p>The <em>top-level function</em> is the DSP <em>kernel</em>'s' entrypoint, which, in the final <em>block design</em>, will be connected to other peripherals, such as the <strong>i²s</strong> and the <strong>processing system</strong>, with the help of various bus interfaces (AXI, AXI-Lite).</p>
<p>Its <strong>arguments</strong> should be considered as a <strong>list of input &amp; output ports</strong>, with:</p>
<ul>
<li><strong>pointer</strong> arguments being <strong>output</strong> arguments (or both <em>input</em> &amp; <em>output</em> arguments)</li>
<li><strong>non-pointer</strong> arguments being <strong>input</strong> arguments only.</li>
<li><strong>array</strong> arguments can be both.</li>
</ul>
<p>It's <strong>signature</strong> should always be <code>void syfala(...)</code>:</p>
<pre><code class="language-cpp">// examples/cpp/templates/gain.cpp

/* Top-level interface function */
void syfala (
        // Audio input/output ports (variable):
        sy_ap_int audio_in[INPUTS],
        sy_ap_int audio_out[OUTPUTS],
        // The following arguments are required and should not be changed:
           int arm_ok,
         bool* i2s_rst,
        float* mem_zone_f,
          int* mem_zone_i,
          bool bypass,
          bool mute,
          bool debug
) {
    [...]
</code></pre>
<p>Again, each <strong>audio input &amp; output arguments</strong> have to be formatted exactly like the following:</p>
<pre><code class="language-cpp">void syfala (
        // Audio input/output ports (variable):
        sy_ap_int audio_in[INPUTS],
        sy_ap_int audio_out[OUTPUTS],
</code></pre>
<p>And have to be followed by <strong>these exact same arguments</strong> (which we will present in the next sections):</p>
<pre><code class="language-cpp">        // The following arguments are required and their respective names should not be changed:
           int arm_ok,
         bool* i2s_rst,
        float* mem_zone_f,
          int* mem_zone_i,
          bool bypass,
          bool mute,
          bool debug
) {
    [...]
</code></pre>
<p>Below, the HLS interface <strong>pragmas should also remain the same,</strong> they're here to indicate to <strong>Vitis HLS</strong> two things:</p>
<ul>
<li>to split the input/output audio arguments into <strong>individual ports</strong> (which will be named <code>audio_in_0</code>, <code>audio_in_1</code>, <code>audio_out_0</code>, <code>audio_out_1</code>)</li>
<li>to map some of the top-level arguments to <em>AXI</em> and <em>AXI-Lite</em> bus interfaces (which will be further explained later).</li>
</ul>
<pre><code>#pragma HLS array_partition variable=audio_in type=complete
#pragma HLS array_partition variable=audio_out type=complete
#pragma HLS INTERFACE s_axilite port=arm_ok
#pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram
#pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram
</code></pre>
<h3 id="initialization">Initialization</h3>
<h4 id="waiting-for-arm-initialization">Waiting for ARM initialization</h4>
<p>Since the <em>DSP kernel</em> and the <em>ARM</em> are <strong>not synchronized at a sample-rate level</strong>, and the <em>ARM</em> has to first initialize a few peripherals (audio codecs, GPIOs, UART...) before being able to do anything else, it is necessary for the <em>DSP kernel</em> to wait for the <code>arm_ok</code> <strong>signal</strong> to be received before doing any initialization or processing.</p>
<p>Once the <em>ARM</em> is ready, the initialization routine can be done manually with, for example, a static <code>initialization</code> variable. In our <em>stereo gain</em> example, we do:</p>
<pre><code class="language-cpp">static bool initialization = true;
[...]
    /* Initialization and computations can start after the ARM
     * has been initialized */
    if (arm_ok) {
        /* First function call: initialization */
        if (initialization) {
            // Initialize all runtime data here.
            // don't forget to toggle the variable off
            initialization = false;
        } else {
</code></pre>
<h3 id="bypassmute-switches">Bypass/mute switches</h3>
<p>In all standard <strong>syfala designs</strong>, the <code>bypass</code> and <code>mute</code> ports of a <em>DSP kernel</em> are pre-mapped to <code>SW0</code> and <code>SW1</code> in Zybo Z10/Z20 boards. You can choose to acknowledge and process them if you want:</p>
<pre><code class="language-cpp">        } else {
            /* Every other iterations:
             * either process the bypass &amp; mute switches... */
            if (bypass) {
                audio_out[0] = audio_in[0];
                audio_out[1] = audio_in[1];
            } else if (mute) {
                audio_out[0] = 0;
                audio_out[1] = 0;
            } else {
</code></pre>
<h3 id="dsp-code">DSP code</h3>
<p>Finally, here is an example of a <em>processing function</em> taking advantage of the <code>Syfala::HLS::ioreadf()</code> and <code>Syfala::HLS::iowritef()</code> convenience functions in order to switch back &amp; forth between <code>float</code> and <code>sy_ap_int</code> types.</p>
<pre><code class="language-cpp">            } else {
                /* ... or compute samples here */
                compute(audio_in, audio_out);
            }
</code></pre>
<p>For our <em>stereo gain</em> example, we first convert the input data to <em>float</em>, multiply it by <code>0.5f</code> and <strong>write it back to the output ports</strong>.</p>
<pre><code class="language-cpp">static void compute(sy_ap_int const inputs[], sy_ap_int outputs[])
{
    // if you need to convert to float, use the following:
    // (audio inputs and outputs are 24-bit integers by default)
    float f0 = Syfala::HLS::ioreadf(inputs[0]) * 0.5f;
    float f1 = Syfala::HLS::ioreadf(inputs[1]) * 0.5f;
    Syfala::HLS::iowritef(f0, outputs[0]);
    Syfala::HLS::iowritef(f1, outputs[1]);
}
</code></pre>
<h2 id="building-and-flashing-with-the-syfala-cli">Building and flashing with the syfala CLI</h2>
<p><strong>syfala</strong> works the same way with C++ targets, you'll only need to replace the Faust <code>.dsp</code> target with your <code>.cpp</code> file in the command line. We can now try to synthesize our <em>stereo gain DSP kernel</em>, in order to see if our code compiles:</p>
<pre><code class="language-shell">syfala examples/cpp/templates/gain.cpp --board Z20 --hls
</code></pre>
<p>Once the high-level synthesis is done, <strong>syfala</strong> should display the <strong>Vitis HLS estimate</strong> of the <strong>kernel's latency and resource utilization</strong>:</p>
<pre><code>DSP     2% (6)
FF     ~0% (997)
LUT     3% (2070)
BRAM    0% (0)

Latency:
Tot. 47 Cycles 0.382us
</code></pre>
<h2 id="verifying-code-with-c-simulation-csim">Verifying code with C simulation (CSIM)</h2>
<p>We know now that our code compiles, but we won't be able to test it until the full <strong>Vivado synthesis</strong> &amp; <strong>implementation</strong> are done, which, depending on your machine, can take up some time. We'll then have to flash the device, connect an audio-input and a headset to the board, and see if the <em>stereo gain</em> in our example is properly applied.</p>
<p>Needless to say, the process is a bit long and tedious. You don't really want to go through all of that too many times when you're debugging code, and that's precisely where <strong>C simulation</strong> (<strong>CSIM</strong>) comes into play.</p>
<p>C simulation is an important Vitis HLS feature, which allows you to test your C-written kernel without having to get through the full synthesis process. In short: Vitis HLS <em>guarantees</em> (with a few exceptions) that the outputs of your kernel is going to be the same as they would be in a real context of execution.</p>
<h3 id="using-pre-defined-generic-templates">Using pre-defined generic templates:</h3>
<p>Now, if we get back to our <em>stereo gain</em> example, and since it is a really simple one, we will take advantage of the generic <strong>CSIM C++ template</strong> that is available in the syfala source tree (located in <code>tests/csim/csim_cpp_template.cpp</code>). Here's an example of command that can be used:</p>
<pre><code class="language-shell">syfala examples/cpp/templates/gain.cpp --csim tests/csim/csim_cpp_template.cpp --csim-inputs tests/stimuli --csim-iter 64
# output results will be stored in reports/csim/gain/out0.txt &amp; reports/csim/gain/out1.txt
</code></pre>
<p>Where:</p>
<ul>
<li><code>--csim tests/csim/csim_cpp_template.cpp</code> - the simulation test file.</li>
<li><code>--csim-inputs tests/stimuli</code> - we specify using the <code>tests/stimuli</code> directory to fetch input samples.</li>
<li><code>tests/stimuli</code> contains two <code>.txt</code> files, named <code>in0.txt</code> and <code>in1.txt</code> and are filled with normalized (<code>-1.f</code> to <code>1.f</code>) floating point values.</li>
<li><code>--csim-iter 64</code> - the DSP kernel will be called 64 times (64 samples).</li>
</ul>
<p>We can finally verify the outputs of our <em>stereo gain</em> kernel, by comparing the input <em>stimuli</em> files with the output files (output samples should be <code>input/2</code>).</p>
<h3 id="writing-your-own-csim">Writing your own CSIM</h3>
<p>While the generic template will work for simple <em>DSP kernels</em> that have the same top-level function signature, you will have to write your own CSIM file to validate kernels that have more complex interfaces. In order to do this, and since the generic template is scripted and a bit complicated to read, let's take inspiration from the <code>csim_cpp_template_gain.cpp</code> example file, and see what it is actually doing:</p>
<ul>
<li>We first <strong>declare the syfala top-level function prototype</strong>, which is going to have the <strong>exact same signature</strong> as in our <code>gain.cpp</code> file.</li>
</ul>
<pre><code class="language-cpp">// tests/csim/csim_cpp_template_gain.cpp

void syfala (
     sy_ap_int audio_in[2],
     sy_ap_int audio_out[2],
           int arm_ok,
         bool* i2s_rst,
        float* mem_zone_f,
          int* mem_zone_i,
          bool bypass,
          bool mute,
          bool debug
);
</code></pre>
<ul>
<li>We then instantiate and pre-initialize <strong>the values</strong> that are going to be passed to the <code>syfala</code> <strong>function arguments</strong>:</li>
</ul>
<pre><code class="language-cpp">sy_ap_int audio_in[2] = {0, 0};
sy_ap_int audio_out[2] = {0, 0};
// Here, we simulate having the ARM initialized and ready, by setting the 'arm_ok' variable to 'true':
int arm_ok   = true;
// The i2s is not part of the simulation, so this really doesn't matter:
bool i2s_rst = false;
// We don't use DDR memory, nor the bypass/mute switches: set everything to zero:
float* mem_zone_f = nullptr;
int* mem_zone_i   = nullptr;
bool bypass = false;
bool mute   = false;
bool debug  = false;
</code></pre>
<ul>
<li>We also instantiate <code>float</code> type copies of inputs and outputs, for setting random input values, and printing outputs.</li>
</ul>
<pre><code class="language-cpp">    float f_inputs[2]  = {0, 0};
    float f_outputs[2] = {0, 0};
</code></pre>
<ul>
<li>Then, call the <code>syfala</code> function with all the proper arguments.</li>
</ul>
<pre><code class="language-cpp">    // For each simulation iteration (set with the '--csim-iter' flag)   
    for (int i = 0; i &lt; SYFALA_CSIM_NUM_ITER; i++) {
            if (i &gt; 0) {
         // first iteration = initialization, inputs will be ignored
         // wait for second iteration.
                f_inputs[0] = (float)rand()/RAND_MAX;
                f_inputs[1] = (float)rand()/RAND_MAX;
            }
            Syfala::HLS::iowritef(f_inputs[0], audio_in[0]);
            Syfala::HLS::iowritef(f_inputs[1], audio_in[1]);
        // call top-level function
            syfala(audio_in, audio_out,
                   arm_ok, &amp;i2s_rst,
                   mem_zone_f, mem_zone_i,
                   bypass, mute, debug
            );
        [...]
    }
</code></pre>
<ul>
<li>Once it is done, fetch and print the input/output samples (as float) :</li>
</ul>
<pre><code class="language-cpp">        [...]
        f_outputs[0] = Syfala::HLS::ioreadf(audio_out[0]);
        f_outputs[1] = Syfala::HLS::ioreadf(audio_out[1]);
        printf(&quot;[ch0] input: %f, result: %f\n&quot;, f_inputs[0], f_outputs[0]);
        printf(&quot;[ch1] input: %f, result: %f\n&quot;, f_inputs[1], f_outputs[1]);
    }
</code></pre>
<h2 id="optimizing-code">Optimizing code</h2>
<p>For simple examples, such as our previous <em>stereo-gain kernel</em>, there's obviously not going to be an immediate and imperative need for optimization. Consequently, we will this time get our hands on something a little <strong>more resource and computation hungry</strong>.</p>
<p>In audio digital signal processing, <strong>FIR filters</strong> are encountered on a very regular basis, and, depending on the number of coefficients that they have, they can be tricky to implement on FPGAs, especially if no optimizations are made. Let's have a look at our <code>examples/cpp/fir/fir.cpp</code> example:  </p>
<pre><code class="language-cpp">#include &quot;coeffs.hpp&quot;

static float coeffs[] = {
    0.000000000000000000,
    -0.000000914435621961,
    0.000000000000000000,
    0.000008609100789076,
    [...]
};

#define INPUTS 0
#define OUTPUTS 2
#define NCOEFFS 115

static float samples[NCOEFFS];
static float sawtooth;

float compute_fir() {
    float out = 0;
    samples[0] = sawtooth;
    for (int n = 0; n &lt; NCOEFFS; ++n) {
         out += mem[n] * coeffs115[n];
    }
    for (int j0 = NCOEFFS-1; j0 &gt; 0; --j0) {
         mem[j0] = samples[j0-1];
    }
    sawtooth += 0.01f;
    sawtooth = fmodf(sawtooth, 1.f);
    return out;
}
</code></pre>
<p>In this example, we first statically define a bunch of <strong>FIR coefficients</strong> in the <code>examples/cpp/fir/coeffs.hpp</code> header, as well as a <strong>zero-initialized array</strong> (<code>samples[NCOEFFS]</code>), which will be used to store the previous samples. The <code>compute_fir</code> function generates a really <strong>basic phasor/sawtooth signal</strong>, and feed it into the FIR filter. Once all the samples are computed for <code>NCOEFFS</code>, we <strong>shift</strong> the <code>samples[]</code> array by one in the right direction. Then, as in our previous examples, we call the '<strong>compute</strong>' function from the <code>syfala</code> top-level function. In this case, we are going to write the same signal on both left and right output channels.</p>
<pre><code class="language-cpp">                /* ... or compute samples here
                 * if you need to convert to float, use the following:
                 * (audio inputs and outputs are 24-bit integers) */
                float f = compute_fir();
                Syfala::HLS::iowritef(f, audio_out[0]);
                Syfala::HLS::iowritef(f, audio_out[1]);
</code></pre>
<h3 id="monitoring-latency-resource-utilization">Monitoring latency &amp; resource utilization</h3>
<p>Now, in order to evaluate the program's performance and efficiency, the first thing that we can do is run the <strong>High Level Synthesis step</strong> and carefully read the <strong>output results</strong>. This can be done using the following command:</p>
<pre><code class="language-shell">syfala examples/cpp/fir/fir.cpp --board Z10 --hls
</code></pre>
<p>which is going to give us this <strong>estimate</strong>:</p>
<pre><code>fir.cpp Z10 48000 24 (Vitis HLS estimate)
115 coefficients

- DSP:   8% (7)
- Reg:   5% (1829)
- LUT:  20% (3617)
- BRAM:  2% (3)

Tot. 1057 Cycles, 8.602us
Max. 2559 Cycles, 20,8333us
Lat. 41%
</code></pre>
<p>Needless to say, even for a <strong>Zybo Z7-10</strong>, this is not really satisfying: if we project ourselves <strong>linearly</strong>, it means that we could probably only <strong>fit at best a 300 coefficients FIR filter</strong> or so without reaching the <strong>maximum sample latency</strong>. Let's try it out with 300 coefficients now:</p>
<pre><code>fir.cpp Z10 48000 24 (Vitis HLS estimate)
300 coefficients

- DSP:   8% (7)
- Reg:   5% (1837)
- LUT:  20% (3619)
- BRAM:  2% (4)

Tot. 2722 Cycles, 22.152us
Max. 2559 Cycles, 20,8333us
Lat. 106%
</code></pre>
<p>With a <strong>300-coefficients filter</strong>, we even actually go a little bit <strong>above max latency</strong>. On the other hand, we can see that the resources stay pretty much the same as before, so there's probably room for improvement here in terms of <strong>balance</strong> between latency &amp; resource utilization, and the first thing we can do to remedy this problem would maybe be to use some of the <strong>Vitis HLS C/C++ pragmas</strong>.</p>
<h3 id="using-optimization-directives-pragmas">Using optimization directives &amp; pragmas</h3>
<p>Now, what we really want Vitis HLS to do here, for the latency to drop down, would be to <strong>parallelize the computations</strong> a bit more. If we go through <strong>Vitis HLS documentation</strong>, there are a couple of things that can be tried in order to do that, without modifying the code too much. Our first choice here would be to use the <strong>unroll #pragma</strong>, which could introduce more parallelization in our <strong>accumulation loop</strong>:</p>
<pre><code class="language-cpp">float compute_fir() {
    float out = 0;
    mem[0] = sawtooth;
    for (int n = 0; n &lt; NCOEFFS; ++n) {
        #pragma HLS UNROLL
         out += mem[n] * coeffs[n];
    }
    [...]
</code></pre>
<p>If we try to run HLS with this code, we see that pretty much nothing happens (the results may even be  worse than before). That's because this particular accumulation loop cannot really be parallelized without using what we call a <strong>balanced tree</strong> (in our case, an 'adder tree'). By default, Vitis HLS does not automatically make this optimization for floating-point operations, but it can be enabled using the <code>--unsafe-math-optimizations</code> (or <code>--umo</code>) flag in the syfala command line:</p>
<pre><code class="language-shell">syfala examples/cpp/fir/fir300.cpp --hls --umo
</code></pre>
<p>Let's now try to see what it's giving us for our <strong>300 coefficients</strong> example:</p>
<pre><code>fir.cpp Z10 48000 (Vitis HLS estimate)
300 coefficients

- DSP:  31% (25)
- Reg:  18% (6532)
- LUT:  66% (3619)
- BRAM:  1% (2)

Tot. 529 Cycles, 4.536us
Max. 2559 Cycles, 20,8333us
Lat. 20%
</code></pre>
<p>The results are definitely more reasonable in terms of latency. On the other hand, we can see that the resources (<strong>LUTs</strong> in particular) have increased a lot. If we push it a little bit more, let's say with <strong>600 coefficients</strong> this time, this is what we get:</p>
<pre><code>fir.cpp Z10 48000 (Vitis HLS estimate)
600 coefficients

- DSP:  31% (25)
- Reg:  23% (8101)
- LUT:  85% (15019)
- BRAM:  1% (2)

Tot. 987 Cycles, 8.537us
Max. 2559 Cycles, 20,8333us
Lat. 38%
</code></pre>
<p>With <strong>600 coefficients</strong>, we're still okay on latency, but the <strong>Lookup Table</strong> (<strong>LUT</strong>) <strong>number</strong> is now getting dangerously <strong>high</strong>. </p>
<p>Remember: the numbers shown on these reports are only <strong>an estimate</strong>, which means that this number could be in reality a bit higher, introducing the risk that our kernel might not actually fit on the Zybo Z7-10 board. </p>
<h4 id="accurate-reports">Accurate reports</h4>
<p>In a situation like this one, it is usually a good idea to tell Vitis HLS that we need <strong>a more accurate report</strong> on the allocated resources. Adding the <code>--accurate-use</code> flag to the syfala command line will do exactly that for us:</p>
<pre><code class="language-shell">syfala examples/cpp/fir300.cpp --hls --umo --accurate-use
</code></pre>
<p>This will tell Vitis HLS to run both the <strong>synthesis</strong> and <strong>implementation</strong> <strong>steps</strong> on the <em>DSP kernel</em> only (not on the final design). It usually takes more time (approximately 5 to 10 minutes, depending on the kernel), but it will give precise and valuable information on the resources that will be used on the board:</p>
<pre><code>                                GUIDELINE
- DSP:  31% (25)        OK (80%)
- Reg:  22% (7912)      OK (50%)
- LUT:  70% (12332)     WARNING (70%)
- BRAM:  1% (2)         OK (80%)
</code></pre>
<p>If we now look at the <strong>GUIDELINE</strong> column, we can see that we have indeed a <strong>WARNING</strong> on the LUT section, which basically means that the design may not fit on the board. But instead of trying to run the full synthesis and hope for the best, maybe we can tweak the <strong>pragmas</strong> a little more, to give ourselves a safer margin.</p>
<p><strong>Vitis HLS documentation</strong> tells us that we can add to the <strong>UNROLL pragma ** a parameter called<code>factor</code> , which basically represents the level of parallelization that we want to introduce in the loop. When this parameter is </strong>not explicitly set<strong>, Vitis HLS will </strong>fully unroll the loop<strong>, which might explain why the number of LUTs has sky-rocketted in our previous examples. If we tune this factor with a lower number, it might help bring down the utilization of this specific FPGA resource. Let's try it now with a </strong>factor** <code>10</code>, and see what it does:</p>
<pre><code class="language-cpp">float compute_fir() {
    [...]
    for (int n = 0; n &lt; NCOEFFS; ++n) {
        #pragma HLS UNROLL factor=10
         out += samples[n] * coeffs[n];
    }
    [...]
</code></pre>
<p>Which is going to give us:</p>
<pre><code>fir.cpp Z10 48000 (Vitis HLS estimate)
600 coefficients

- DSP:  15% (12)
- Reg:   9% (3452)
- LUT:  28% (4966)
- BRAM:  3% (4)

Tot. 1139 Cycles, 9.269us
Max. 2559 Cycles, 20,8333us
Lat. 44%
</code></pre>
<p>This is starting to get a lot better, and if we go up to <strong>1000 coefficients</strong> now:</p>
<pre><code>fir.cpp Z10 48000 (Vitis HLS estimate)
1000 coefficients

- DSP:  15% (12)
- Reg:   9% (3452)
- LUT:  28% (4966)
- BRAM:  3% (4)

Tot. 1859 Cycles, 15.129us
Max. 2559 Cycles, 20,8333us
Lat. 72%
</code></pre>
<p>The results here are getting really interesting, since we can clearly see that <strong>the resources used are exactly the same</strong> as our 600 coefficients example. Latency is the only thing that has increased, from 44% to 72%, which remains a somewhat comfortable margin.</p>
<h3 id="using-a-sample-block-configuration-multisample">Using a 'sample block' configuration (--multisample)</h3>
<p>Another method that can be used in order to balance latency and resource utilization would be for the DSP kernel <strong>to process a block of samples</strong> instead of a single one, i.e. to '<strong>bufferize</strong>' the signal to maximize efficiency and parallelization. Not unlike CPUs,  this may also result in better FPGA resource dispatch and/or throughput, but has on the other hand the drawback of introducing <strong>I/O latency</strong>.</p>
<p><strong>Syfala</strong> supports <strong>sample block processing</strong> for both Faust and C++ targets,  by adding the <code>--multisample &lt;N&gt;</code> flag:</p>
<pre><code class="language-shell">syfala examples/cpp/templates/gain-multisample.cpp --multisample 16 --hls
</code></pre>
<p>For C++ targets, the code needs to be adapted a bit, since we now have <strong>FIFO arrays</strong> as inputs and outputs, we have to declare them as <strong>C multidimensional arrays</strong>, like the following: </p>
<pre><code class="language-cpp">void syfala (
        sy_ap_int audio_in[INPUTS][SYFALA_BLOCK_NSAMPLES],
        sy_ap_int audio_out[OUTPUTS][SYFALA_BLOCK_NSAMPLES],
        [...]
</code></pre>
<pre><code class="language-cpp">#pragma HLS INTERFACE ap_fifo port=audio_in
#pragma HLS INTERFACE ap_fifo port=audio_out
#pragma HLS array_partition variable=audio_in type=complete
#pragma HLS array_partition variable=audio_out type=complete
#pragma HLS INTERFACE s_axilite port=arm_ok
#pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram
#pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram
</code></pre>
<p>Within the top-level function, this also changes the way we have to process the <strong>bypass/mute switches</strong>:</p>
<pre><code class="language-cpp">        } else {
            /* Every other iterations:
             * either process the bypass &amp; mute switches... */
            if (bypass) {
                for (int n = 0; n &lt; OUTPUTS; ++n) {
                    for (int m = 0; m &lt; SYFALA_BLOCK_NSAMPLES; ++m) {
                             audio_out[n][m] = audio_in[n][m];
                    }
                }
            } else if (mute) {
                for (int n = 0; n &lt; OUTPUTS; ++n) {
                    for (int m = 0; m &lt; SYFALA_BLOCK_NSAMPLES; ++m) {
                             audio_out[n][m] = 0;
                    }
                }
</code></pre>
<p>And finally our <strong>compute function</strong>:</p>
<pre><code class="language-cpp">            } else {
                /* ... or compute samples here */
                compute(audio_in, audio_out);
            }
</code></pre>
<pre><code class="language-cpp">// examples/cpp/templates/gain-multisample.cpp

static void compute(sy_ap_int const inputs[INPUTS][SYFALA_BLOCK_NSAMPLES],
                    sy_ap_int outputs[OUTPUTS][SYFALA_BLOCK_NSAMPLES])
{
    for (int n = 0; n &lt; OUTPUTS; ++n)
        for (int m = 0; m &lt; SYFALA_BLOCK_NSAMPLES; ++m) {
            // if you need to convert to float, use the following:
            // (audio inputs and outputs are 24-bit integers by default)
            float f = Syfala::HLS::ioreadf(inputs[n][m]) * 0.5f;
            Syfala::HLS::iowritef(f, outputs[n][m]);
        }
    }
}
</code></pre>
<h4 id="fir-example">FIR example</h4>
<p>Let's get back to our FIR example, in order to see what can be done to optimize things a bit more. An unoptimized <code>multisample</code> example can be found in <code>examples/cpp/fir/fir-multisample.cpp</code>. </p>
<p>Let's see what kind of results we get with a <strong>block of size 16 and 300 coefficients</strong>:</p>
<pre><code class="language-shell">syfala examples/cpp/fir/fir-multisample.cpp --board Z10 --multisample 16 --hls
</code></pre>
<pre><code>fir-multisample.cpp Z10 48000 (Vitis HLS estimate)
block size: 16 samples
300 coefficients

- DSP:   8% (7)
- Reg:   5% (1935)
- LUT:  21% (3829)
- BRAM:  3% (4)

Tot. 43585 Cycles, 0.355ms
Per sample: 2724 Cycles.
Max. 2559 Cycles, 20,8333us
Lat. 106%
</code></pre>
<p>Compared to our unoptimized 'one-sample' FIR example with the <strong>same number of coefficients</strong>, and considering we also introduce <strong>an I/O latency of 16 samples</strong> (about 0.3 milliseconds), we can say with confidence that this is not really good, and that's essentially because - if we carefully look at the more advanced reports that Vitis HLS is giving us - <strong>the samples are still processed sequentially</strong>, which is not going to introduce a lot of changes compared to the single-sample version. Consequently, even if we unroll our accumulation loop as we did before, the results are also going to be more or less the same. </p>
<p>[...]</p>
<h4 id="csim-with-multisample-configuration">CSIM with --multisample configuration:</h4>
<pre><code class="language-shell">syfala examples/cpp/templates/gain-multisample.cpp
       --multisample 32
       --csim tests/csim/csim_cpp_template_multisample.cpp
       --csim-inputs tests/stimuli
       --csim-iter 5
# output results will be stored in reports/csim/gain-multisample/out0.txt &amp; reports/csim/gain-multisample/out1.txt
</code></pre>
<h2 id="sharing-processingcontrol-with-the-arm-executable">Sharing processing/control with the ARM executable</h2>
<p>Since the resources on a FPGA are far from being infinite, it is usually preferable to use a custom <strong>ARM</strong> executable for some specific use-cases, such as:</p>
<ul>
<li>Initialization of <strong>constants</strong>, <strong>wavetables</strong>...</li>
<li>Long <strong>delay-lines</strong> (stored/initialized in DDR memory).</li>
<li><strong>Control-rate</strong> computations.</li>
<li>etc.</li>
</ul>
<p>This is exactly what <strong>syfala</strong> does under the hood with <strong>Faust programs</strong>: control-rate expressions, resulting from the sliders/button being interacted with, are for instance made on the ARM, and shared through a memory bus called <strong>AXI-Lite</strong>. </p>
<p>The following example shows how we can implement a similar (though simpler) control-rate <em>gain</em> parameter, which we will be able update on the console and share with the DSP kernel.</p>
<h3 id="basic-axi-lite-control-example">Basic AXI-Lite control example</h3>
<p>This example, which you can find in <code>examples/cpp/templates/gain-control-hls.cpp</code>, is almost exactly the same as our previous <code>gain.cpp</code> example. The only difference is that we want to make <strong>variable</strong> the <code>gain</code> parameter that we <em>hardcoded</em> to <code>0.5f</code> before. All we basically need to do here is to introduce a new floating-point argument <code>gain</code> <strong>in the top-level function</strong>, which will also be declared as an <strong>AXI-Lite</strong> interface port using the appropriate <code>pragma</code>: </p>
<pre><code class="language-cpp">void syfala (
        sy_ap_int audio_in[INPUTS],
        sy_ap_int audio_out[OUTPUTS],
           [...]
           float gain
) {
[...]
#pragma HLS INTERFACE s_axilite port=gain
</code></pre>
<p>For the rest of the code, we simply add <code>gain</code> to the <code>compute()</code> function's arguments, and then apply it to the inputs.</p>
<pre><code class="language-cpp">            } else {
                /* ... or compute samples here */
                compute(audio_in, audio_out, gain);
            }
</code></pre>
<pre><code class="language-cpp">static void compute(sy_ap_int const inputs[],
                    sy_ap_int outputs[]
                    float gain) {
    float f0 = Syfala::HLS::ioreadf(inputs[0]) * gain;
    float f1 = Syfala::HLS::ioreadf(inputs[1]) * gain;
    Syfala::HLS::iowritef(f0, outputs[0]);
    Syfala::HLS::iowritef(f1, outputs[1]);
}
</code></pre>
<p>That's it! On the <strong>HLS side</strong> of things, it remains pretty simple. On the <strong>ARM side</strong>, it gets unfortunately a bit more complicated, as we are going to see now :-)</p>
<h4 id="dsp-kernel-drivers">DSP kernel drivers</h4>
<p>We already know that Vitis HLS is going to take our <code>gain-control-hls.cpp</code> file and generate the VHDL-equivalent, which is then going to be integrated in our final design. But it's not the only thing that it does: among other things, <strong>it also generates 'drivers' for interacting with the kernel from the ARM</strong>.</p>
<p>Let's first <strong>synthesize</strong> our DSP kernel with Vitis HLS, and take a look at some of the files that are generated in the <code>build</code> directory:</p>
<pre><code class="language-shell">syfala examples/cpp/templates/gain-control-hls.cpp --hls
</code></pre>
<p>If we now go in the <code>build/syfala_ip/syfala/impl/ip/drivers/syfala_v1_0/src</code> directory, we see that a Makefile and <strong>some C files have been generated</strong>, specifically:</p>
<pre><code>- xsyfala.c
- xsyfala.h
- xsyfala_hw.h
- xsyfala_linux.c
- xsyfala_sinit.c
</code></pre>
<p>We're not going to go into details about each file: the one that is truly interesting to us in the context of our example is the <code>xsyfala.h</code> <strong>C header</strong> . If we <strong>open this file</strong>, we see that the following <strong>function prototypes</strong> are declared: </p>
<pre><code class="language-cpp">void XSyfala_Set_arm_ok(XSyfala *InstancePtr, u32 Data);
u32 XSyfala_Get_arm_ok(XSyfala *InstancePtr);
void XSyfala_Set_mem_zone_f(XSyfala *InstancePtr, u64 Data);
u64 XSyfala_Get_mem_zone_f(XSyfala *InstancePtr);
void XSyfala_Set_mem_zone_i(XSyfala *InstancePtr, u64 Data);
u64 XSyfala_Get_mem_zone_i(XSyfala *InstancePtr);
void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data);
u32 XSyfala_Get_gain(XSyfala *InstancePtr);
</code></pre>
<p>You can see that these functions' names match some of the arguments that we put in the top-level function. That's because these arguments are already registered as <strong>AXI</strong> or <strong>AXI-Lite</strong> interface arguments in our <strong>DSP kernel code</strong>:</p>
<pre><code class="language-cpp">void syfala (
           [...]
           int arm_ok,
        float* mem_zone_f,
          int* mem_zone_i,
         float gain
) {
#pragma HLS INTERFACE s_axilite port=arm_ok
#pragma HLS INTERFACE s_axilite port=gain
#pragma HLS INTERFACE m_axi port=mem_zone_f latency=30 bundle=ram
#pragma HLS INTERFACE m_axi port=mem_zone_i latency=30 bundle=ram
</code></pre>
<p>In our case, since the other arguments <code>arm_ok</code>, <code>mem_zone_f</code> and <code>mem_one_i</code> are already taken of by <strong>syfala</strong>, the one that is going to be useful to us is the <code>gain</code> parameter, and, specifically, its <strong>'setter' function</strong>:</p>
<pre><code class="language-cpp">void XSyfala_Set_gain(XSyfala *InstancePtr, u32 Data)
</code></pre>
<h4 id="writing-the-arm-executable">Writing the ARM executable</h4>
<p>In order to code the executable that is going to run on the ARM, we will take the code from<code>source/arm/baremetal/arm_minimal.cpp</code>, which contains all that is necessary for the application to run properly, and we are going to add our <code>gain</code> <strong>control function</strong>. The result can be seen in <code>examples/cpp/templates/gain-control-arm.cpp</code>.</p>
<p>In our <code>update_gain()</code> function, we are simply going to fetch a new <code>gain</code> value using <code>scanf</code>, and update it on the FPGA using the <code>XSyfala_Set_gain</code> <strong>driver function</strong>:</p>
<pre><code class="language-cpp">static void update_gain(XSyfala&amp; syfala) {
    static float gain = 1.f;
    printf(&quot;Enter gain value (from 0.f to 1.f)\r\n&quot;);
    scanf(&quot;%f&quot;, &amp;gain);
    printf(&quot;Gain: %f\r\n&quot;, gain);
    XSyfala_Set_gain(&amp;syfala, *reinterpret_cast&lt;u32*&gt;(&amp;gain));
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: floating-point data have to be set using <code>reinterpret_cast&lt;u32*&gt;</code>, otherwise, it will be interpreted as an integer and truncated. </p>
</blockquote>
<p>In the <code>main()</code> function, all we have to do now is call our <code>update_gain()</code> function in the <strong>main event loop</strong>, passing it the <code>XSyfala</code> handle <code>struct</code>.</p>
<pre><code class="language-cpp">int main(int argc, char* argv[]) {
    XSyfala syfala;
    UART::data uart;
    // UART &amp; GPIO should be initialized first,
    // i.e. before outputing any information on leds &amp; stdout.
    GPIO::initialize();
    UART::initialize(uart);
    // Wait for all peripherals to be initialized
    Status::waiting(RN(&quot;[status] Initializing peripherals &amp; modules&quot;));
    Audio::initialize();
    IP::initialize(syfala);
    IP::set_arm_ok(&amp;syfala, true);
    Status::ok(RN(&quot;[status] Application ready, now running...&quot;));

    // main event loop:
    while (true) {
       // --------------------------------------------------------
       update_gain(syfala);
       sleep(1);
       // --------------------------------------------------------
    }
    return 0;
}
</code></pre>
<h4 id="running-syfala">Running syfala</h4>
<p>Finally, <strong>to fully run syfala on our example</strong>, including the ARM executable, we need to add the <code>--arm-target</code> <strong>flag</strong> to the command line, with the path to our <code>.cpp</code> file as an argument:</p>
<pre><code class="language-shell">syfala examples/cpp/templates/gain-control-hls.cpp --arm-target examples/cpp/templates/gain-control-arm.cpp --board Z10
</code></pre>
<h3 id="delay-line-axi-example-ddr-memory">Delay-line AXI example (DDR memory)</h3>
<p>[...]</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Copyright &copy; 2023 <a href="https://team.inria.fr/emeraude/">Emeraude</a></small><br>
            
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = "../.."</script>
    
    <script src="../../js/base.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
